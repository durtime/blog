{
    "version": "https://jsonfeed.org/version/1",
    "title": "Durtime • All posts by \"nginx\" tag",
    "description": "The aroma of black tea no longer exists",
    "home_page_url": "https://my.durtime.top",
    "items": [
        {
            "id": "https://my.durtime.top/posts/2bee8b90/",
            "url": "https://my.durtime.top/posts/2bee8b90/",
            "title": "nginx配置",
            "date_published": "2023-02-23T13:28:25.833Z",
            "content_html": "<h1 id=\"nginxlocation常见配置指令alias-root-proxy_pass-路径问题\"><a class=\"markdownIt-Anchor\" href=\"#nginxlocation常见配置指令alias-root-proxy_pass-路径问题\">#</a> Nginx——location 常见配置指令，alias、root、proxy_pass 路径问题</h1>\n<p>1.【alias】</p>\n<p>别名配置，用于访问文件系统，在匹配到 location 配置的 URL 路径后，指向【alias】配置的路径。如：</p>\n<p>location /test/<br>\n{<br>\nalias /home/sftp/img/;<br>\n}<br>\nlocation /test/aaa/<br>\n{<br>\nalias /home/sftp/img/;<br>\n}<br>\nlocation /test/aaa/bbb/<br>\n{<br>\nalias /home/sftp/img/;<br>\n}<br>\n 即：请求 /test/1.jpg、/test/aaa/1.jpg、/test/aaa/bbb/1.jpg（省略了协议与域名），将会返回文件 /home/sftp/img/1.jpg。</p>\n<p>注意 alias 后面有没有 “/” 要和 location 后面 “/” 保持一致，否则找不到资源文件</p>\n<p>2.【root】</p>\n<p>根路径配置，用于访问文件系统，在匹配到 location 配置的 URL 路径后，指向【root】配置的路径，并把 location 配置路径附加到其后。如：</p>\n<p>location /test/<br>\n{<br>\nroot /home/sftp/img/;<br>\n}<br>\n 即：请求 /test/1.jpg（省略了协议与域名），将会返回文件 /home/sftp/img/test/1.jpg，相较于 alias，使用 root 会把 /test/ 附加到根目录之后。</p>\n<p>3.【proxy_pass】</p>\n<p>反向代理配置，用于代理请求，适用于前后端负载分离或多台机器、服务器负载分离的场景，在匹配到 location 配置的 URL 路径后，转发请求到【proxy_pass】配置的 URL，是否会附加 location 配置路径与【proxy_pass】配置的路径后是否有 &quot;/“有关，有”/&quot; 则不附加，proxy_pass 带 “/” 类似于 alias 如：</p>\n<p>location /test/<br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080/\">http://127.0.0.1:8080/</a>;<br>\n}<br>\nlocation /test/aaa/<br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080/\">http://127.0.0.1:8080/</a>;<br>\n}<br>\nlocation /test/aaa/bbb/<br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080/\">http://127.0.0.1:8080/</a>;<br>\n}<br>\n 在 tomcat 的 webapp/ROOT/ 放一个 1.png 图片</p>\n<p>即：请求 /test/1.jpg、/test/aaa/1.jpg、/test/aaa/bbb/1.jpg（省略了协议与域名），将会被 nginx 转发请求到<a href=\"http://127.0.0.1:8080/1.jpg%EF%BC%88%E6%9C%AA%E9%99%84%E5%8A%A0/test/%E5%92%8C/test%E5%AD%90%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%EF%BC%89%E3%80%82\"> http://127.0.0.1:8080/1.jpg（未附加 /test/ 和 /test 子目录路径）。</a></p>\n<p>proxy_pass 不带 “/” 类似于 root 如：</p>\n<p>location /test<br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080\">http://127.0.0.1:8080</a>;<br>\n}<br>\nlocation /test/aaa<br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080\">http://127.0.0.1:8080</a>;<br>\n}<br>\nlocation /test/aaa/bbb<br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080\">http://127.0.0.1:8080</a>;<br>\n}<br>\n 需要在 tomcat webapp/ROOT/ 创建 aaa/bbb 目录 之后把 1.png 方式 aaa 和 bbb 目录中</p>\n<p>即：请求 /test/1.jpg，/test/aaa/1.jpg，/test/aaa/bbb/1.jpg（省略了协议与域名），将会被 nginx 转发请求到<a href=\"http://127.0.0.1:8080/test/1.jpg,http://127.0.0.1:8080/test/aaa/1.jpg,http://127.0.0.1:8080/test/aaa/bbb/1.jpg%EF%BC%88%E9%99%84%E5%8A%A0/test/%E4%BB%A5%E5%8F%8A%E5%AD%90%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%EF%BC%89%E3%80%82\"> http://127.0.0.1:8080/test/1.jpg,http://127.0.0.1:8080/test/aaa/1.jpg,http://127.0.0.1:8080/test/aaa/bbb/1.jpg（附加 /test/ 以及子目录路径）。</a></p>\n<p>以下特殊 是 proxy_pass <a href=\"http://127.0.0.1:8080/img\">http://127.0.0.1:8080/img</a>;  带 img 目录的情况</p>\n<p>location /test 不能加 “/” 如果加了，那么这个 proxy_pass <a href=\"http://127.0.0.1:8080/img;%E4%B9%9F%E5%BE%97%E5%8A%A0proxy_pass\">http://127.0.0.1:8080/img; 也得加 proxy_pass</a> <a href=\"http://127.0.0.1:8080/img/\">http://127.0.0.1:8080/img/</a>;   否则<a href=\"http://127.0.0.1:8080/img1.png\"> http://127.0.0.1:8080/img1.png</a><br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080/img\">http://127.0.0.1:8080/img</a>;    效果一样<br>\n proxy_pass <a href=\"http://127.0.0.1:8080/img/\">http://127.0.0.1:8080/img/</a>;<br>\n}</p>\n<p>location /test/aaaa<br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080/img\">http://127.0.0.1:8080/img</a>;   效果一样，和 y 一开始说 proxy_pass 末尾加不加 “/” 行为不一样了<br>\n proxy_pass <a href=\"http://127.0.0.1:8080/img/\">http://127.0.0.1:8080/img/</a>;<br>\n}<br>\n 即：请求 /test/1.jpg、/test/aaa/1.jpg（省略了协议与域名），将会被 nginx 转发请求到<a href=\"http://127.0.0.1:8080/img/1.jpg%EF%BC%88%E6%9C%AA%E9%99%84%E5%8A%A0/test/%E5%92%8C%E5%AD%90%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%EF%BC%89%E3%80%82\"> http://127.0.0.1:8080/img/1.jpg（未附加 /test/ 和子目录路径）。</a></p>\n<p>匹配规则：</p>\n<p>location 语法</p>\n<p …=\"\">location [=|<sub>|</sub>*|^~] /uri/</p>\n<p>= 开头表示精确匹配  此时和 location 中的 root 没关系了。至于 location 外面的 root 才能影响 = 的配置路径</p>\n<dl>\n<dt>^~ 开头表示 uri 以某个常规字符串开头，理解为匹配 url 路径即可。nginx 不对 url 做编码，因此请求为 /static/20%/aa，可以被规则 ^~ /static//aa 匹配到（注意是空格）。</dt>\n<dd>开头表示区分大小写的正则匹配</dd>\n</dl>\n<p>~* 开头表示不区分大小写的正则匹配</p>\n<p>!<sub> 和！</sub>* 分别为区分大小写不匹配及不区分大小写不匹配 的正则</p>\n<p>/ 通用匹配，任何请求都会匹配到。</p>\n<p>第一：一般匹配和精准匹配</p>\n<p>1、精准匹配和一般匹配，uri 后面不带 “/” 匹配</p>\n<p>如图：</p>\n<p>请求 URL：<a href=\"http://192.168.60.106/zg/\">http://192.168.60.106/zg/</a>  访问时匹配的是：/zg</p>\n<p>2、精准匹配和一般匹配，uri 前面和后面都不带 “/”</p>\n<p>如图：</p>\n<p>请求 URL：<a href=\"http://192.168.60.106/zg/\">http://192.168.60.106/zg/</a> 访问时匹配的是：= zg</p>\n<p>3、精准匹配和一般匹配，uri 带 &quot;/“和不带”/&quot; 匹配</p>\n<p>如图：</p>\n<p>请求 URL：<a href=\"http://192.168.60.106/zg/\">http://192.168.60.106/zg/</a> 访问时匹配的是：/zg/ 顺序换也是一样</p>\n<p>综上所述：路径相同时的精准匹配优先，必须是满足 /uri/ 或者 uri，要么 uri 两边都加 /，要么 uri 两边都不加斜杆的情况</p>\n<p>4、精准匹配 就是访问路径和 location 后面的完全一样 包括（前后的 &quot;/&quot;）</p>\n<p>server {<br>\nlisten       80;<br>\nserver_name  localhost;<br>\nroot /opt/wubo; 起作用 全局</p>\n<pre><code>     index 1.html; 起作用    全局\n    location = /jetto &#123;  \n\n            root和alias此时不起作用；\n\n            index index.html;也不起作用;\n    &#125;\n</code></pre>\n<p>正则</p>\n<pre><code>    location ~ /jetto/.*/\\.html &#123;  \n\n            root和alias此时不起作用；\n\n            index index.html;也不起作用;\n    &#125;\n</code></pre>\n<p>正则</p>\n<pre><code>location  ~ /wubo/(.*\\.mp4) &#123;\n\n        root和alias此时起作用；\n\n        alias video/mp4/$1;\n        #echo_sleep 4;\n        #echo &quot;2222&quot;;\n        #alias video/mp4;\n        #mp4;\n        #index wubo.mp4;\n    &#125;\n</code></pre>\n<p>正则</p>\n<pre><code>  location ~ /jetto &#123;  \n\n            root和alias此时起作用；\n\n            index index.html;也起作用;\n    &#125;\n</code></pre>\n<p>}</p>\n<p>访问路径：<a href=\"http://ip\">http://ip</a>:port/jetto    本地真实路径：/opt/wubo/jetto  如果没有上面红色部分默认是 /opt/wubo/html/jetto</p>\n<p>5、通用匹配 以最长 uri 匹配优先</p>\n<p>server {<br>\nlisten       80;<br>\nserver_name  localhost;<br>\nroot /opt/wubo; 起作用 全局</p>\n<pre><code>     index 1.html; 起作用    全局\n    location  /jetto &#123;  \n\n        #root alias index起作用，此时root alias的路径想对与全局的相对路径;index 会覆盖全局 index 的默认值\n        #root  /opt/wubo/html;  # 本地真实路径/opt/wubo/html/jetto\n        #root  html;           #本地真实路径/opt/wubo/html/jetto\n        #root  /opt/wubo/jettopro;   #本地真实路径/opt/wubo/jettopro/jetto\n        #root   jettopro;            #本地真实路径/opt/wubo/jettopro/jetto\n        #alias  /opt/wubo/jettoapi;   #本地真实路径/opt/wubo/jettoapi\n        alias   jettoapi;            #本地真实路径/opt/wubo/jettoapi \n        index index.html jwplayer.html; \n    &#125;\n</code></pre>\n<p>}</p>\n<p>访问路径：<a href=\"http://ip\">http://ip</a>:port/jetto    本地真实路径：/opt/wubo/jetto/1.html  如果没有上面红色部分默认是 /opt/wubo/html/jetto/index.html</p>\n<p>第二：^~ 开头的非正则匹配和一般匹配</p>\n<p>^~ 代表非正则匹配，非正则，不需要继续正则匹配。</p>\n<p>^~</p>\n<p><sup>~: 如果这个匹配使用</sup>〜前缀，搜索停止。这个前缀官网和网上都说得很含糊，加上这个前缀，是会停止搜索正则匹配，但是对一般匹配是不会停止的，也就是说还是可以匹配到一般匹配的。</p>\n<p>请求 url： <a href=\"http://ip\">http://ip</a>:port/images/aa/test.jpg，匹配结果：/images/aa/</p>\n<p><a href=\"http://ip\">http://ip</a>:port/api/                                     匹配结果：/jettoapi/index.html</p>\n<p><a href=\"http://ip\">http://ip</a>:port/api/wubo                                     匹配结果：/jettoapi/index.html</p>\n<p>意思就是说 ^~ 的作用对一般匹配不会停止，对正则匹配会停止正则匹配是： ~</p>\n<dl>\n<dt>7、^~ 开头的非正则匹配和正则匹配</dt>\n<dd>开头表示区分大小写的正则匹配</dd>\n</dl>\n<p>如图：</p>\n<p>请求 url： <a href=\"http://192.168.60.106/images/aa/test.jpg%EF%BC%8C%E5%8C%B9%E9%85%8D%E7%BB%93%E6%9E%9C%EF%BC%9A%5E~/images/\">http://192.168.60.106/images/aa/test.jpg，匹配结果：^~/images/</a></p>\n<p>location /api {<br>\nalias   jettoapi;            #/opt/wubo/jettoapi<br>\nindex 1.html;<br>\n}</p>\n<p>访问路径：<a href=\"http://ip\">http://ip</a>:port/api/wubo   本地路径：/opt/wubo/jettoapi/wubo/1.html</p>\n<p>location /api/wubo {<br>\nalias   jettoapi;            #/opt/wubo/jettoapi<br>\nindex 1.html;<br>\n}</p>\n<p>访问路径：<a href=\"http://ip\">http://ip</a>:port/api/wubo   本地路径：/opt/wubo/jettoapi/1.html</p>\n<p>访问路径和 location 中的路径完全匹配的话 就不需要在本地真实路径下有对应的访问路径，如果 location 的路径只是访问路径中一部分，则需要在本地路径有对应访问中的路径</p>\n<p>8、严格精准匹配和正则匹配</p>\n<p>如图：</p>\n<p>严格精准匹配，如果被严格精准匹配到了，则不会继续搜索正则匹配</p>\n<p>如果<a href=\"http://192.168.60.106\"> http://192.168.60.106</a>, 这个就严格精准匹配到了 /, 则不会继续匹配～.html$</p>\n<p>如果：<a href=\"http://192.168.60.106/index.html%EF%BC%8C%E5%88%99%E4%BC%9A%E8%A2%AB/\">http://192.168.60.106/index.html，则会被 /</a> 匹配到，但不是严格精准匹配，则会继续搜索正则匹配</p>\n<p>9、正则匹配规则</p>\n<p>都是正则 uri 的情况下，匹配是按照编辑顺序的</p>\n<p>如图</p>\n<p>请求 URL：<a href=\"http://192.168.60.106/prefix/index.html%EF%BC%8C%E4%BC%9A%E4%BC%98%E5%85%88%E5%8C%B9%E9%85%8D%E5%89%8D%E9%9D%A2%E5%AE%9A%E4%B9%89%E7%9A%84location%E3%80%82\">http://192.168.60.106/prefix/index.html，会优先匹配前面定义的 location。</a></p>\n<p>10、@开头的 uri</p>\n<p>如图：</p>\n<p>@开头的，如果请求的 URI 存在，则本 nginx 返回对应的页面；如果不存在，<a href=\"http://xn--baidu-ck2hx5qkfy26l4ku3qtkv9d.com\">则把请求代理到 baidu.com</a> 上去做个弥补，其实就是做了一个容错，把找不到的 url 全部转发到 fallback 的反向代理服务器去。</p>\n<p>最后总结：</p>\n<ol>\n<li>\n<p>先判断精准命中，如果命中，立即返回结果并结束解析过程</p>\n</li>\n<li>\n<p>判断普通命中，如果有多个命中，记录下来最长的命中结果</p>\n</li>\n</ol>\n<p>3、如果是 ^~ 开头的命中，则不会继续搜索正则命中，但是会继续搜索一般命中</p>\n<ol start=\"4\">\n<li>继续判断正则表达式的解析结果，按配置里的正则表达式顺序为准，由上到下开始匹配，一旦匹配成功立刻返回结果，并结束解析过程。</li>\n</ol>\n<p>延伸分析：a. 普通命中：顺序无所谓，是因为按命中长短来确定的   b. 正则命中：顺序有所谓，因为是从前往后命中的</p>\n<p>注意：当和正则一起使用寻找目录的时候，以下一定是配套的使用。A 相当于定义局部资源目录，B 相当于在 A 定义好的资源目录里面寻找资源</p>\n<p>C 是在全局定义一个资源目录</p>\n<p>A： location /wubo {<br>\nalias   video/mp4;           #/opt/wubo/video/mp4<br>\n}<br>\nB：  location  ~ /wubo/.mp4$ {<br>\nmp4;<br>\n#limit_conn addr 20;<br>\n#limit_rate 2000k;<br>\n}</p>\n<p>访问：<a href=\"http://ip\">http://ip</a>:port/wubo/wubo.mp4</p>\n<p>server： root  /opt/wubo/video/mp4;</p>\n<p>C：location  ~ .mp4$ {<br>\nmp4;<br>\n#limit_conn addr 20;<br>\n#limit_rate 2000k;<br>\n}</p>\n<p>访问：<a href=\"http://ip\">http://ip</a>:port/wubo.mp4</p>\n<p><a href=\"https://blog.csdn.net/shangrila_kun/article/details/89643964\">https://blog.csdn.net/shangrila_kun/article/details/89643964</a></p>\n<p>Nginx 是什么</p>\n<p>Nginx（发音同 engine x）是一个异步框架的 Web 服务器，也可以用作反向代理，负载平衡器 和 HTTP 缓存。<br>\n也有人这么解释<br>\n nginx 是一款自由的、开源的、高性能的 HTTP 服务器和反向代理服务器；<br>\n同时也是一个 IMAP、POP3、SMTP 代理服务器；<br>\nnginx 可以作为一个 HTTP 服务器进行网站的发布处理，<br>\n另外 nginx 可以作为反向代理进行负载均衡的实现。<br>\nnginx.conf 的目录结构<br>\n nginx.conf 的目录结构<br>\n整个 conf 文件分为 ** 全局块、events 块、http 块、server 块、location 块 **。每个块有每个块的作用域，越外层的块作用域就包含内部块的作用域，如全局块作用域就包含 events 块、http 块、server 块和 location 块</p>\n<pre><code>              #全局块\n</code></pre>\n<p>event {              #events 块<br>\n…<br>\n}</p>\n<p>http {               #http 块</p>\n<pre><code>server&#123;         #server块\n    ...         #server全局块\n\n    location&#123;   #location块\n        ...\n    &#125;\n\n    location&#123;   #location块\n        ...\n    &#125;\n&#125;\n\nserver&#123;         #server块\n    ...\n&#125;\n...             #http全局块\n</code></pre>\n<p>}</p>\n<p>http 块<br>\n http 块是 Nginx 服务器配置中的重要部分，代理、缓存和日志定义等绝大多数的功能和第三方模块的配置都可以放在这模块中。作用包括：文件引入、MIME-Type 定义、日志自定义、是否使用 sendfile 传输文件、连接超时时间、单连接请求数上限等。</p>\n<p>server 块<br>\n server 块，虚拟主机（虚拟服务器）。作用：使得 Nginx 服务器可以在同一台服务器上至运行一组 Nginx 进程，就可以运行多个网站。</p>\n<p>location 块<br>\n location 块是 server 块的一个指令。作用：基于 Nginx 服务器接收到的请求字符串，虚拟主机名称（ip，域名）、url 匹配，对特定请求进行处理。</p>\n<p>location 说明<br>\n location 语法<br>\n location [=|<sub>|</sub>*|^~|@] /uri/ <ruby> … } ，意思是可以以 “=” 或 “ ~* ” 或 “ ~ ” 或 “ <rp>【</rp><rt>~ ” 或 “@” 符号为前缀，\n当然也可以没有前缀（因为 [A] 是表示可选的 A ； A|B 表示 A 和 B 选一个），紧接着是 /uri/ ，\n再接着是 {…</rt><rp>】</rp></ruby> 指令块，整个意思是对于满足这样条件的 /uri/ 适用指令块 {…} 的指令。</p>\n<p>location 的分类<br>\n location 分为两类，一类为普通 location，一类为正则 location。</p>\n<p>1 普通 location<br>\n “普通 location” 是以 “ = ” 或 “ ^~ ” 为前缀或者没有任何前缀的 /uri/<br>\n2 正则 location<br>\n “正则 location” 是以 “ ~ ” 或 “ ~* ” 为前缀的 /uri/</p>\n<p>多个 location 场景下的 location 匹配<br>\n Nginx 的 location 匹配规则是：“正则 location” 让步 “普通 location” 的严格精确匹配结果；但覆盖 “普通 location ” 的最大前缀匹配结果。</p>\n<p>例子 1 先普通 location，再正则 location 匹配</p>\n<p>server {<br>\nlisten       9090;<br>\nserver_name  localhost;<br>\nlocation / {<br>\nroot   html;<br>\nindex  index.html index.htm;<br>\ndeny all;<br>\n}<br>\nlocation ~ .html$ {<br>\nallow all;<br>\n}<br>\n}</p>\n<p>location / {… deny all;} 普通 location 以 “ / ” 开始的 URI 请求（注意任何 HTTP 请求都必然以 “/ ” 开始，所以 “ / ” 的意思是所有的请求都能被匹配上），都拒绝访问； location ~.html$ {allow all;} 正则 location 以 .html 结尾的 URI 请求，都允许访问。</p>\n<p>测试结果</p>\n<p>[root@web108 ~]# curl <a href=\"http://localhost:9090/\">http://localhost:9090/</a></p>\n<html>\n<head><title>403 Forbidden</title></head>\n<body bgcolor=”white”>\n<center><h1>403 Forbidden</h1></center>\n<hr><center>nginx/1.1.0</center>\n</body>\n</html>\n<p>[root@web108 ~]# curl <a href=\"http://localhost:9090/index.html\">http://localhost:9090/index.html</a></p>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n</head>\n<body bgcolor=”white” text=”black”>\n<center><h1>Welcome to nginx!</h1></center>\n</body>\n</html>\n<p>[root@web108 ~]# curl <a href=\"http://localhost:9090/index_notfound.html\">http://localhost:9090/index_notfound.html</a></p>\n<html>\n<head><title>404 Not Found</title></head>\n<body bgcolor=”white”>\n<center><h1>404 Not Found</h1></center>\n<hr><center>nginx/1.1.0</center>\n</body>\n</html>\n<p>curl <a href=\"http://localhost:9090/\">http://localhost:9090/</a> 的结果是 “403 Forbidden”，说明被匹配到 “ location / {…deny all;} ” 了，原因很简单 HTTP 请求 GET / 被 “严格精确” 匹配到了普通 location / {} ，则会停止搜索正则 location ；<br>\ncurl <a href=\"http://localhost:9090/index.html\">http://localhost:9090/index.html</a> 结果是 “Welcome to nginx!”，说明没有被 “ location / {…deny all;} ” 匹配，否则会 403 Forbidden ，但 /index.html 的确也是以 “ / ” 开头的，只不过此时的普通 location / 的匹配结果是 “最大前缀” 匹配，所以 Nginx 会继续搜索正则 location ， location ~ .html$ 表达了以 .html 结尾的都 allow all; 于是接着就访问到了实际存在的 index.html 页面。<br>\ncurl <a href=\"http://localhost:9090/index_notfound.html\">http://localhost:9090/index_notfound.html</a> 同样的道理先匹配 location / {} ，但属于 “普通 location 的最大前缀匹配”，于是后面被 “正则 location ” location ~ .html$ {} 覆盖了，最终 allow all ； 但的确目录下不存在 index_notfound.html 页面，于是 404 Not Found 。<br>\n如果此时我们访问 <a href=\"http://localhost:9090/index.txt\">http://localhost:9090/index.txt</a> 会是什么结果呢？显然是 deny all ；因为先匹配上了 location / {…deny all;} 尽管属于 “普通 location ” 的最大前缀匹配结果，继续搜索正则 location ，但是 /index.txt 不是以 .html 结尾的，正则 location 失败，最终采纳普通 location 的最大前缀匹配结果，于是 deny all 了。</p>\n<p>例子 2 普通 location 的 “隐式” 严格匹配</p>\n<p>// 在例子 1 的基础上增加精确匹配<br>\n server {<br>\nlisten       9090;<br>\nserver_name  localhost;<br>\nlocation /exact/match.html {<br>\nallow all;<br>\n}<br>\nlocation / {<br>\nroot   html;<br>\nindex  index.html index.htm;<br>\ndeny all;<br>\n}<br>\nlocation ~ .html$ {<br>\nallow all;<br>\n}<br>\n}<br>\n————————————————</p>\n<p>[root@web108 ~]# curl <a href=\"http://localhost:9090/exact/match.html\">http://localhost:9090/exact/match.html</a></p>\n<html>\n<head><title>404 Not Found</title></head>\n<body bgcolor=”white”>\n<center><h1>404 Not Found</h1></center>\n<hr><center>nginx/1.1.0</center>\n</body>\n</html>\n结果进一步验证了“普通 location ”的“严格精确”匹配会终止对正则 location 的搜索。这里我们小结下“普通 location”与“正则 location ”的匹配规则：先匹配普通 location ，再匹配正则 location ，但是如果普通 location 的匹配结果恰好是“严格精确（ exact match ）”的，则 nginx 不再尝试后面的正则 location ；如果普通 location 的匹配结果是“最大前缀”，则正则 location 的匹配覆盖普通 location 的匹配。也就是前面说的“正则 location 让步普通location 的严格精确匹配结果，但覆盖普通 location 的最大前缀匹配结果”。\n————————————————\n<p>普通 location 的 “显式” 严格匹配和 “ ^~ ” 前缀<br>\n上面我们演示的普通 location 都是不加任何前缀的，其实普通 location 也可以加前缀：“^~” 和 “ = ”。其中 “ ^~” 的意思是 “非正则，不需要继续正则匹配”，也就是通常我们的普通 location ，还会继续搜索正则 location （恰好严格精确匹配除外），但是 nginx 很人性化允许配置人员告诉 nginx 某条普通 location ，无论最大前缀匹配，还是严格精确匹配都终止继续搜索正则 location ；而 “ = ” 则表达的是普通 location 不允许 “最大前缀” 匹配结果，必须严格等于，严格精确匹配。<br>\n————————————————<br>\n 例子 3</p>\n<p>server <ruby>\n       listen       9090;\n       server_name  localhost;\n          location /exact/match.html {\n           allow all;\n       }\n           location <rp>【</rp><rt>~ / {\n           root   html;\n           index  index.html index.htm;\n           deny all;\n       </rt><rp>】</rp></ruby><br>\nlocation ~ .html$ {<br>\nallow all;<br>\n}<br>\n}</p>\n<p>测试</p>\n<p>curl <a href=\"http://localhost:9090/\">http://localhost:9090/</a>\t403 Forbidden\t403 Forbidden<br>\ncurl <a href=\"http://localhost:9090/index.html\">http://localhost:9090/index.html</a>\tWelcome to nginx!\t403 Forbidden<br>\ncurl <a href=\"http://localhost:9090/index_notfound.html\">http://localhost:9090/index_notfound.html</a>\t404 Not Found\t403 Forbidden<br>\ncurl <a href=\"http://localhost:9090/exact/match.html\">http://localhost:9090/exact/match.html</a>\t404 Not Found\t404 Not Found<br>\n————————————————<br>\n 正则 location 与编辑顺序<br>\n location 的指令与编辑顺序无关，这句话不全对。对于普通 location 指令，匹配规则是：最大前缀匹配（与顺序无关），如果恰好是严格精确匹配结果或者加有前缀 “^~” 或 “ = ”（符号 “ = ” 只能严格匹配，不能前缀匹配），则停止搜索正则 location ；但对于正则 location 的匹配规则是：按编辑顺序逐个匹配（与顺序有关），只要匹配上，就立即停止后面的搜索。</p>\n<p>server <ruby>\n       listen       9090;\n       server_name  localhost;\n       location ~ \\.html$ {\n           allow all; \n       }  \n       location ~ <rp>【</rp><rt>/prefix/.*\\.html$ {\n           deny all;  \n       </rt><rp>】</rp></ruby><br>\n}<br>\nserver <ruby>\n       listen       9090;\n       server_name  localhost;\n       location ~ <rp>【</rp><rt>/prefix/.*\\.html$ {\n           deny all;  \n       </rt><rp>】</rp></ruby><br>\nlocation ~ .html$ {<br>\nallow all;<br>\n}<br>\n}<br>\n————————————————</p>\n<p>curl <a href=\"http://localhost:9090/regextest.html\">http://localhost:9090/regextest.html</a>\t404 Not Found\t404 Not Found<br>\ncurl <a href=\"http://localhost:9090/prefix/regextest.html\">http://localhost:9090/prefix/regextest.html</a>\t404 Not Found\t403 Forbidden<br>\nLocation ~ ^/prefix/.*.html$ {deny all;} 表示正则 location 对于以 /prefix/ 开头，<br>\n.html 结尾的所有 URI 请求，都拒绝访问；   location ~.html<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi>a</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>w</mi><mi>a</mi><mi>l</mi><mi>l</mi><mo separator=\"true\">;</mo></mrow><mtext>表示正则</mtext><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mtext>对于以</mtext><mi mathvariant=\"normal\">.</mi><mi>h</mi><mi>t</mi><mi>m</mi><mi>l</mi><mtext>结尾的</mtext><mi>U</mi><mi>R</mi><mi>I</mi><mtext>请求，都允许访问。实际上，</mtext><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mi>i</mi><mi>x</mi><mtext>的是 </mtext><mover accent=\"true\"><mi>h</mi><mo>˙</mo></mover><mi>t</mi><mi>m</mi><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">{allow all;} \n 表示正则 location 对于以 .html 结尾的 URI 请求，都允许访问。 实际上，\n prefix 的是 ~\\.html</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1257em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">ll</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">ll</span><span class=\"mpunct\">;</span></span><span class=\"mord cjk_fallback\">表示正则</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">oc</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mord cjk_fallback\">对于以</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord cjk_fallback\">结尾的</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord cjk_fallback\">请求，都允许访问。实际上，</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">re</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">x</span><span class=\"mord cjk_fallback\">的是</span><span class=\"mspace nobreak\"> </span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9313em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">h</span></span><span style=\"top:-3.2634em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1389em;\"><span class=\"mord\">˙</span></span></span></span></span></span></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 的子集。在 “配置 3.1” 下，两个请求都匹配上 location ~.html$ {allow all;} ，<br>\n并且停止后面的搜索，于是都允许访问， 404 Not Found ；在 “配置 3.2” 下， /regextest.html 无法匹配 prefix ，<br>\n于是继续搜索～.html$ ，允许访问，于是 404 Not Found ；然而 /prefix/regextest.html 匹配到 prefix ，<br>\n于是 deny all ， 403 Forbidden 。</p>\n",
            "tags": [
                "教程",
                "nginx"
            ]
        }
    ]
}