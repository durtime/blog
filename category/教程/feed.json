{
    "version": "https://jsonfeed.org/version/1",
    "title": "Durtime • All posts by \"教程\" category",
    "description": "The aroma of black tea no longer exists",
    "home_page_url": "https://my.durtime.top",
    "items": [
        {
            "id": "https://my.durtime.top/posts/2bee8b90/",
            "url": "https://my.durtime.top/posts/2bee8b90/",
            "title": "Win10 ssh",
            "date_published": "2023-03-09T04:34:41.000Z",
            "content_html": "<p>配置过程</p>\n<h2 id=\"1-首先生成密钥对\"><a class=\"markdownIt-Anchor\" href=\"#1-首先生成密钥对\">#</a> 1. 首先生成密钥对</h2>\n<p>ssh-keygen -t rsa   #-t 表示类型选项，这里采用 rsa 加密算法</p>\n<h2 id=\"2-上传公钥\"><a class=\"markdownIt-Anchor\" href=\"#2-上传公钥\">#</a> 2. 上传公钥</h2>\n<p>ssh-copy-id <a href=\"mailto:root@192.168.0.1\">root@192.168.0.1</a><br>\n 遇到问题<br>\n在 windows10 上配置时，会遇到如下错误：</p>\n<p>ssh-copy-id : 无法将 “ssh-copy-id” 项识别为 cmdlet、函数、脚本文件或可运行程序的名称。</p>\n<p>解决方案是在 powershell 中，先执行以下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ssh-copy-id([string]$userAtMachine, $args)&#123;   </span><br><span class=\"line\">    $publicKey = &quot;$ENV:USERPROFILE&quot; + &quot;/.ssh/id_rsa.pub&quot;</span><br><span class=\"line\">    if (!(Test-Path &quot;$publicKey&quot;))&#123;</span><br><span class=\"line\">        Write-Error &quot;ERROR: failed to open ID file &#x27;$publicKey&#x27;: No such file&quot;            </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        &amp; cat &quot;$publicKey&quot; | ssh $args $userAtMachine &quot;umask 077; test -d .ssh || mkdir .ssh ; cat &gt;&gt; .ssh/authorized_keys || exit 1&quot;      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3测试\"><a class=\"markdownIt-Anchor\" href=\"#3测试\">#</a> 3. 测试</h2>\n<p>ssh root@公网 IP</p>\n",
            "tags": [
                "教程",
                "ssh"
            ]
        },
        {
            "id": "https://my.durtime.top/posts/57ee7c1d/",
            "url": "https://my.durtime.top/posts/57ee7c1d/",
            "title": "Hexo搭建",
            "date_published": "2023-02-23T14:05:12.001Z",
            "content_html": "<h1 id=\"github-部署\"><a class=\"markdownIt-Anchor\" href=\"#github-部署\">#</a> GitHub 部署</h1>\n<p>npm install hexo-deployer-git --save</p>\n<p>deploy:<br>\ntype: git<br>\nrepository: <a href=\"mailto:git@github.com\">git@github.com</a>:cndadi/cndadi.github.io.git  #你的仓库地址<br>\n branch: main</p>\n<p>hexo clean<br>\nhexo generate<br>\nhexo deploy</p>\n<h1 id=\"服务端创建-git-仓库\"><a class=\"markdownIt-Anchor\" href=\"#服务端创建-git-仓库\">#</a> 服务端创建 Git 仓库</h1>\n<p>配置免密登录<br>\n配置本地客户端与阿里云服务器端的 ssh 免密登录，方便上传仓库时一键式上传。</p>\n<p>在本地客户端生成并上传公共密钥：</p>\n<h2 id=\"执行完之后一直回车就行\"><a class=\"markdownIt-Anchor\" href=\"#执行完之后一直回车就行\">#</a> 执行完之后一直回车就行</h2>\n<p>ssh-keygen</p>\n<h2 id=\"上传公共密钥到阿里云服务器\"><a class=\"markdownIt-Anchor\" href=\"#上传公共密钥到阿里云服务器\">#</a> 上传公共密钥到阿里云服务器</h2>\n<p>ssh-copy-id root@阿里云公网 IP</p>\n<h2 id=\"测试是否已免密\"><a class=\"markdownIt-Anchor\" href=\"#测试是否已免密\">#</a> 测试是否已免密</h2>\n<p>ssh root@阿里云公网 IP</p>\n<p>服务器上创建一个 Git 仓库，该仓库中新建一个 post-receive 钩子文件。</p>\n<p>cd ~<br>\ngit init --bare hexo.git<br>\nvi ~/hexo.git/hooks/post-receive</p>\n<h2 id=\"填写以下内容其中的work-tree-为-hexo-博客目录\"><a class=\"markdownIt-Anchor\" href=\"#填写以下内容其中的work-tree-为-hexo-博客目录\">#</a> 填写以下内容，其中的–work-tree 为 hexo 博客目录</h2>\n<p>git --work-tree=/data/blog --git-dir=/root/hexo.git checkout -f</p>\n<h2 id=\"授予钩子文件可执行权限\"><a class=\"markdownIt-Anchor\" href=\"#授予钩子文件可执行权限\">#</a> 授予钩子文件可执行权限</h2>\n<p>chmod +x ~/hexo.git/hooks/post-receive<br>\nchmod -R 777 /data/blog</p>\n<p>至此，Git 仓库创建并配置完成，对应的本地客户端也需要配置一下！</p>\n<p>在本地计算机 hexo 的工程目录下，找到 _config.yml，对 deploy 参数进行修改，如下图所示</p>\n<h1 id=\"deployment\"><a class=\"markdownIt-Anchor\" href=\"#deployment\">#</a> Deployment</h1>\n<h2 id=\"docs-httpshexoiodocsone-command-deployment\"><a class=\"markdownIt-Anchor\" href=\"#docs-httpshexoiodocsone-command-deployment\">#</a> Docs: <a href=\"https://hexo.io/docs/one-command-deployment\">https://hexo.io/docs/one-command-deployment</a></h2>\n<p>deploy:<br>\ntype: git<br>\nrepo: root@公网 IP:/root/hexo.git<br>\nbranch: master</p>\n<p>在本地计算机安装插件: hexo-deployer-git 和 hexo-server，插件的作用分别是使用 Git 自动部署，和 hexo 本地简单的服务器：</p>\n<p>登录后复制<br>\n npm install hexo-deployer-git --save<br>\nnpm install hexo-server</p>\n<h2 id=\"配置全局变量\"><a class=\"markdownIt-Anchor\" href=\"#配置全局变量\">#</a> 配置全局变量</h2>\n<p>git config --global <a href=\"http://user.name\">user.name</a> “你的账号”<br>\ngit config --global user.email “你的邮箱”</p>\n<h2 id=\"生成发布-hexo-博客\"><a class=\"markdownIt-Anchor\" href=\"#生成发布-hexo-博客\">#</a> 生成发布 Hexo 博客</h2>\n<p>hexo clean<br>\nhexo generate<br>\nhexo deploy</p>\n",
            "tags": [
                "教程",
                "Hexo"
            ]
        },
        {
            "id": "https://my.durtime.top/posts/2bee8b90/",
            "url": "https://my.durtime.top/posts/2bee8b90/",
            "title": "nginx配置",
            "date_published": "2023-02-13T01:34:41.000Z",
            "content_html": "<h1 id=\"nginxlocation常见配置指令alias-root-proxy_pass-路径问题\"><a class=\"markdownIt-Anchor\" href=\"#nginxlocation常见配置指令alias-root-proxy_pass-路径问题\">#</a> Nginx——location 常见配置指令，alias、root、proxy_pass 路径问题</h1>\n<p>1.【alias】</p>\n<p>别名配置，用于访问文件系统，在匹配到 location 配置的 URL 路径后，指向【alias】配置的路径。如：</p>\n<p>location /test/<br>\n{<br>\nalias /home/sftp/img/;<br>\n}<br>\nlocation /test/aaa/<br>\n{<br>\nalias /home/sftp/img/;<br>\n}<br>\nlocation /test/aaa/bbb/<br>\n{<br>\nalias /home/sftp/img/;<br>\n}<br>\n 即：请求 /test/1.jpg、/test/aaa/1.jpg、/test/aaa/bbb/1.jpg（省略了协议与域名），将会返回文件 /home/sftp/img/1.jpg。</p>\n<p>注意 alias 后面有没有 “/” 要和 location 后面 “/” 保持一致，否则找不到资源文件</p>\n<p>2.【root】</p>\n<p>根路径配置，用于访问文件系统，在匹配到 location 配置的 URL 路径后，指向【root】配置的路径，并把 location 配置路径附加到其后。如：</p>\n<p>location /test/<br>\n{<br>\nroot /home/sftp/img/;<br>\n}<br>\n 即：请求 /test/1.jpg（省略了协议与域名），将会返回文件 /home/sftp/img/test/1.jpg，相较于 alias，使用 root 会把 /test/ 附加到根目录之后。</p>\n<p>3.【proxy_pass】</p>\n<p>反向代理配置，用于代理请求，适用于前后端负载分离或多台机器、服务器负载分离的场景，在匹配到 location 配置的 URL 路径后，转发请求到【proxy_pass】配置的 URL，是否会附加 location 配置路径与【proxy_pass】配置的路径后是否有 &quot;/“有关，有”/&quot; 则不附加，proxy_pass 带 “/” 类似于 alias 如：</p>\n<p>location /test/<br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080/\">http://127.0.0.1:8080/</a>;<br>\n}<br>\nlocation /test/aaa/<br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080/\">http://127.0.0.1:8080/</a>;<br>\n}<br>\nlocation /test/aaa/bbb/<br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080/\">http://127.0.0.1:8080/</a>;<br>\n}<br>\n 在 tomcat 的 webapp/ROOT/ 放一个 1.png 图片</p>\n<p>即：请求 /test/1.jpg、/test/aaa/1.jpg、/test/aaa/bbb/1.jpg（省略了协议与域名），将会被 nginx 转发请求到<a href=\"http://127.0.0.1:8080/1.jpg%EF%BC%88%E6%9C%AA%E9%99%84%E5%8A%A0/test/%E5%92%8C/test%E5%AD%90%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%EF%BC%89%E3%80%82\"> http://127.0.0.1:8080/1.jpg（未附加 /test/ 和 /test 子目录路径）。</a></p>\n<p>proxy_pass 不带 “/” 类似于 root 如：</p>\n<p>location /test<br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080\">http://127.0.0.1:8080</a>;<br>\n}<br>\nlocation /test/aaa<br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080\">http://127.0.0.1:8080</a>;<br>\n}<br>\nlocation /test/aaa/bbb<br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080\">http://127.0.0.1:8080</a>;<br>\n}<br>\n 需要在 tomcat webapp/ROOT/ 创建 aaa/bbb 目录 之后把 1.png 方式 aaa 和 bbb 目录中</p>\n<p>即：请求 /test/1.jpg，/test/aaa/1.jpg，/test/aaa/bbb/1.jpg（省略了协议与域名），将会被 nginx 转发请求到<a href=\"http://127.0.0.1:8080/test/1.jpg,http://127.0.0.1:8080/test/aaa/1.jpg,http://127.0.0.1:8080/test/aaa/bbb/1.jpg%EF%BC%88%E9%99%84%E5%8A%A0/test/%E4%BB%A5%E5%8F%8A%E5%AD%90%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%EF%BC%89%E3%80%82\"> http://127.0.0.1:8080/test/1.jpg,http://127.0.0.1:8080/test/aaa/1.jpg,http://127.0.0.1:8080/test/aaa/bbb/1.jpg（附加 /test/ 以及子目录路径）。</a></p>\n<p>以下特殊 是 proxy_pass <a href=\"http://127.0.0.1:8080/img\">http://127.0.0.1:8080/img</a>;  带 img 目录的情况</p>\n<p>location /test 不能加 “/” 如果加了，那么这个 proxy_pass <a href=\"http://127.0.0.1:8080/img;%E4%B9%9F%E5%BE%97%E5%8A%A0proxy_pass\">http://127.0.0.1:8080/img; 也得加 proxy_pass</a> <a href=\"http://127.0.0.1:8080/img/\">http://127.0.0.1:8080/img/</a>;   否则<a href=\"http://127.0.0.1:8080/img1.png\"> http://127.0.0.1:8080/img1.png</a><br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080/img\">http://127.0.0.1:8080/img</a>;    效果一样<br>\n proxy_pass <a href=\"http://127.0.0.1:8080/img/\">http://127.0.0.1:8080/img/</a>;<br>\n}</p>\n<p>location /test/aaaa<br>\n{<br>\nproxy_pass <a href=\"http://127.0.0.1:8080/img\">http://127.0.0.1:8080/img</a>;   效果一样，和 y 一开始说 proxy_pass 末尾加不加 “/” 行为不一样了<br>\n proxy_pass <a href=\"http://127.0.0.1:8080/img/\">http://127.0.0.1:8080/img/</a>;<br>\n}<br>\n 即：请求 /test/1.jpg、/test/aaa/1.jpg（省略了协议与域名），将会被 nginx 转发请求到<a href=\"http://127.0.0.1:8080/img/1.jpg%EF%BC%88%E6%9C%AA%E9%99%84%E5%8A%A0/test/%E5%92%8C%E5%AD%90%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%EF%BC%89%E3%80%82\"> http://127.0.0.1:8080/img/1.jpg（未附加 /test/ 和子目录路径）。</a></p>\n<p>匹配规则：</p>\n<p>location 语法</p>\n<p …=\"\">location [=|<sub>|</sub>*|^~] /uri/</p>\n<p>= 开头表示精确匹配  此时和 location 中的 root 没关系了。至于 location 外面的 root 才能影响 = 的配置路径</p>\n<dl>\n<dt>^~ 开头表示 uri 以某个常规字符串开头，理解为匹配 url 路径即可。nginx 不对 url 做编码，因此请求为 /static/20%/aa，可以被规则 ^~ /static//aa 匹配到（注意是空格）。</dt>\n<dd>开头表示区分大小写的正则匹配</dd>\n</dl>\n<p>~* 开头表示不区分大小写的正则匹配</p>\n<p>!<sub> 和！</sub>* 分别为区分大小写不匹配及不区分大小写不匹配 的正则</p>\n<p>/ 通用匹配，任何请求都会匹配到。</p>\n<p>第一：一般匹配和精准匹配</p>\n<p>1、精准匹配和一般匹配，uri 后面不带 “/” 匹配</p>\n<p>如图：</p>\n<p>请求 URL：<a href=\"http://192.168.60.106/zg/\">http://192.168.60.106/zg/</a>  访问时匹配的是：/zg</p>\n<p>2、精准匹配和一般匹配，uri 前面和后面都不带 “/”</p>\n<p>如图：</p>\n<p>请求 URL：<a href=\"http://192.168.60.106/zg/\">http://192.168.60.106/zg/</a> 访问时匹配的是：= zg</p>\n<p>3、精准匹配和一般匹配，uri 带 &quot;/“和不带”/&quot; 匹配</p>\n<p>如图：</p>\n<p>请求 URL：<a href=\"http://192.168.60.106/zg/\">http://192.168.60.106/zg/</a> 访问时匹配的是：/zg/ 顺序换也是一样</p>\n<p>综上所述：路径相同时的精准匹配优先，必须是满足 /uri/ 或者 uri，要么 uri 两边都加 /，要么 uri 两边都不加斜杆的情况</p>\n<p>4、精准匹配 就是访问路径和 location 后面的完全一样 包括（前后的 &quot;/&quot;）</p>\n<p>server {<br>\nlisten       80;<br>\nserver_name  localhost;<br>\nroot /opt/wubo; 起作用 全局</p>\n<pre><code>     index 1.html; 起作用    全局\n    location = /jetto &#123;  \n\n            root和alias此时不起作用；\n\n            index index.html;也不起作用;\n    &#125;\n</code></pre>\n<p>正则</p>\n<pre><code>    location ~ /jetto/.*/\\.html &#123;  \n\n            root和alias此时不起作用；\n\n            index index.html;也不起作用;\n    &#125;\n</code></pre>\n<p>正则</p>\n<pre><code>location  ~ /wubo/(.*\\.mp4) &#123;\n\n        root和alias此时起作用；\n\n        alias video/mp4/$1;\n        #echo_sleep 4;\n        #echo &quot;2222&quot;;\n        #alias video/mp4;\n        #mp4;\n        #index wubo.mp4;\n    &#125;\n</code></pre>\n<p>正则</p>\n<pre><code>  location ~ /jetto &#123;  \n\n            root和alias此时起作用；\n\n            index index.html;也起作用;\n    &#125;\n</code></pre>\n<p>}</p>\n<p>访问路径：<a href=\"http://ip\">http://ip</a>:port/jetto    本地真实路径：/opt/wubo/jetto  如果没有上面红色部分默认是 /opt/wubo/html/jetto</p>\n<p>5、通用匹配 以最长 uri 匹配优先</p>\n<p>server {<br>\nlisten       80;<br>\nserver_name  localhost;<br>\nroot /opt/wubo; 起作用 全局</p>\n<pre><code>     index 1.html; 起作用    全局\n    location  /jetto &#123;  \n\n        #root alias index起作用，此时root alias的路径想对与全局的相对路径;index 会覆盖全局 index 的默认值\n        #root  /opt/wubo/html;  # 本地真实路径/opt/wubo/html/jetto\n        #root  html;           #本地真实路径/opt/wubo/html/jetto\n        #root  /opt/wubo/jettopro;   #本地真实路径/opt/wubo/jettopro/jetto\n        #root   jettopro;            #本地真实路径/opt/wubo/jettopro/jetto\n        #alias  /opt/wubo/jettoapi;   #本地真实路径/opt/wubo/jettoapi\n        alias   jettoapi;            #本地真实路径/opt/wubo/jettoapi \n        index index.html jwplayer.html; \n    &#125;\n</code></pre>\n<p>}</p>\n<p>访问路径：<a href=\"http://ip\">http://ip</a>:port/jetto    本地真实路径：/opt/wubo/jetto/1.html  如果没有上面红色部分默认是 /opt/wubo/html/jetto/index.html</p>\n<p>第二：^~ 开头的非正则匹配和一般匹配</p>\n<p>^~ 代表非正则匹配，非正则，不需要继续正则匹配。</p>\n<p>^~</p>\n<p><sup>~: 如果这个匹配使用</sup>〜前缀，搜索停止。这个前缀官网和网上都说得很含糊，加上这个前缀，是会停止搜索正则匹配，但是对一般匹配是不会停止的，也就是说还是可以匹配到一般匹配的。</p>\n<p>请求 url： <a href=\"http://ip\">http://ip</a>:port/images/aa/test.jpg，匹配结果：/images/aa/</p>\n<p><a href=\"http://ip\">http://ip</a>:port/api/                                     匹配结果：/jettoapi/index.html</p>\n<p><a href=\"http://ip\">http://ip</a>:port/api/wubo                                     匹配结果：/jettoapi/index.html</p>\n<p>意思就是说 ^~ 的作用对一般匹配不会停止，对正则匹配会停止正则匹配是： ~</p>\n<dl>\n<dt>7、^~ 开头的非正则匹配和正则匹配</dt>\n<dd>开头表示区分大小写的正则匹配</dd>\n</dl>\n<p>如图：</p>\n<p>请求 url： <a href=\"http://192.168.60.106/images/aa/test.jpg%EF%BC%8C%E5%8C%B9%E9%85%8D%E7%BB%93%E6%9E%9C%EF%BC%9A%5E~/images/\">http://192.168.60.106/images/aa/test.jpg，匹配结果：^~/images/</a></p>\n<p>location /api {<br>\nalias   jettoapi;            #/opt/wubo/jettoapi<br>\nindex 1.html;<br>\n}</p>\n<p>访问路径：<a href=\"http://ip\">http://ip</a>:port/api/wubo   本地路径：/opt/wubo/jettoapi/wubo/1.html</p>\n<p>location /api/wubo {<br>\nalias   jettoapi;            #/opt/wubo/jettoapi<br>\nindex 1.html;<br>\n}</p>\n<p>访问路径：<a href=\"http://ip\">http://ip</a>:port/api/wubo   本地路径：/opt/wubo/jettoapi/1.html</p>\n<p>访问路径和 location 中的路径完全匹配的话 就不需要在本地真实路径下有对应的访问路径，如果 location 的路径只是访问路径中一部分，则需要在本地路径有对应访问中的路径</p>\n<p>8、严格精准匹配和正则匹配</p>\n<p>如图：</p>\n<p>严格精准匹配，如果被严格精准匹配到了，则不会继续搜索正则匹配</p>\n<p>如果<a href=\"http://192.168.60.106\"> http://192.168.60.106</a>, 这个就严格精准匹配到了 /, 则不会继续匹配～.html$</p>\n<p>如果：<a href=\"http://192.168.60.106/index.html%EF%BC%8C%E5%88%99%E4%BC%9A%E8%A2%AB/\">http://192.168.60.106/index.html，则会被 /</a> 匹配到，但不是严格精准匹配，则会继续搜索正则匹配</p>\n<p>9、正则匹配规则</p>\n<p>都是正则 uri 的情况下，匹配是按照编辑顺序的</p>\n<p>如图</p>\n<p>请求 URL：<a href=\"http://192.168.60.106/prefix/index.html%EF%BC%8C%E4%BC%9A%E4%BC%98%E5%85%88%E5%8C%B9%E9%85%8D%E5%89%8D%E9%9D%A2%E5%AE%9A%E4%B9%89%E7%9A%84location%E3%80%82\">http://192.168.60.106/prefix/index.html，会优先匹配前面定义的 location。</a></p>\n<p>10、@开头的 uri</p>\n<p>如图：</p>\n<p>@开头的，如果请求的 URI 存在，则本 nginx 返回对应的页面；如果不存在，<a href=\"http://xn--baidu-ck2hx5qkfy26l4ku3qtkv9d.com\">则把请求代理到 baidu.com</a> 上去做个弥补，其实就是做了一个容错，把找不到的 url 全部转发到 fallback 的反向代理服务器去。</p>\n<p>最后总结：</p>\n<ol>\n<li>\n<p>先判断精准命中，如果命中，立即返回结果并结束解析过程</p>\n</li>\n<li>\n<p>判断普通命中，如果有多个命中，记录下来最长的命中结果</p>\n</li>\n</ol>\n<p>3、如果是 ^~ 开头的命中，则不会继续搜索正则命中，但是会继续搜索一般命中</p>\n<ol start=\"4\">\n<li>继续判断正则表达式的解析结果，按配置里的正则表达式顺序为准，由上到下开始匹配，一旦匹配成功立刻返回结果，并结束解析过程。</li>\n</ol>\n<p>延伸分析：a. 普通命中：顺序无所谓，是因为按命中长短来确定的   b. 正则命中：顺序有所谓，因为是从前往后命中的</p>\n<p>注意：当和正则一起使用寻找目录的时候，以下一定是配套的使用。A 相当于定义局部资源目录，B 相当于在 A 定义好的资源目录里面寻找资源</p>\n<p>C 是在全局定义一个资源目录</p>\n<p>A： location /wubo {<br>\nalias   video/mp4;           #/opt/wubo/video/mp4<br>\n}<br>\nB：  location  ~ /wubo/.mp4$ {<br>\nmp4;<br>\n#limit_conn addr 20;<br>\n#limit_rate 2000k;<br>\n}</p>\n<p>访问：<a href=\"http://ip\">http://ip</a>:port/wubo/wubo.mp4</p>\n<p>server： root  /opt/wubo/video/mp4;</p>\n<p>C：location  ~ .mp4$ {<br>\nmp4;<br>\n#limit_conn addr 20;<br>\n#limit_rate 2000k;<br>\n}</p>\n<p>访问：<a href=\"http://ip\">http://ip</a>:port/wubo.mp4</p>\n<p><a href=\"https://blog.csdn.net/shangrila_kun/article/details/89643964\">https://blog.csdn.net/shangrila_kun/article/details/89643964</a></p>\n<p>Nginx 是什么</p>\n<p>Nginx（发音同 engine x）是一个异步框架的 Web 服务器，也可以用作反向代理，负载平衡器 和 HTTP 缓存。<br>\n也有人这么解释<br>\n nginx 是一款自由的、开源的、高性能的 HTTP 服务器和反向代理服务器；<br>\n同时也是一个 IMAP、POP3、SMTP 代理服务器；<br>\nnginx 可以作为一个 HTTP 服务器进行网站的发布处理，<br>\n另外 nginx 可以作为反向代理进行负载均衡的实现。<br>\nnginx.conf 的目录结构<br>\n nginx.conf 的目录结构<br>\n整个 conf 文件分为 ** 全局块、events 块、http 块、server 块、location 块 **。每个块有每个块的作用域，越外层的块作用域就包含内部块的作用域，如全局块作用域就包含 events 块、http 块、server 块和 location 块</p>\n<p>#全局块</p>\n<p>event {              #events 块<br>\n…<br>\n}</p>\n<p>http {               #http 块</p>\n<pre><code>server&#123;         #server块\n    ...         #server全局块\n\n    location&#123;   #location块\n        ...\n    &#125;\n\n    location&#123;   #location块\n        ...\n    &#125;\n&#125;\n\nserver&#123;         #server块\n    ...\n&#125;\n...             #http全局块\n</code></pre>\n<p>}</p>\n<p>http 块<br>\n http 块是 Nginx 服务器配置中的重要部分，代理、缓存和日志定义等绝大多数的功能和第三方模块的配置都可以放在这模块中。作用包括：文件引入、MIME-Type 定义、日志自定义、是否使用 sendfile 传输文件、连接超时时间、单连接请求数上限等。</p>\n<p>server 块<br>\n server 块，虚拟主机（虚拟服务器）。作用：使得 Nginx 服务器可以在同一台服务器上至运行一组 Nginx 进程，就可以运行多个网站。</p>\n<p>location 块<br>\n location 块是 server 块的一个指令。作用：基于 Nginx 服务器接收到的请求字符串，虚拟主机名称（ip，域名）、url 匹配，对特定请求进行处理。</p>\n<p>location 说明<br>\n location 语法<br>\n location [=|<sub>|</sub>*|^~|@] /uri/ <ruby> … } ，意思是可以以 “=” 或 “ ~* ” 或 “ ~ ” 或 “ <rp>【</rp><rt>~ ” 或 “@” 符号为前缀，\n当然也可以没有前缀（因为 [A] 是表示可选的 A ； A|B 表示 A 和 B 选一个），紧接着是 /uri/ ，\n再接着是 {…</rt><rp>】</rp></ruby> 指令块，整个意思是对于满足这样条件的 /uri/ 适用指令块 {…} 的指令。</p>\n<p>location 的分类<br>\n location 分为两类，一类为普通 location，一类为正则 location。</p>\n<p>多个 location 场景下的 location 匹配<br>\n Nginx 的 location 匹配规则是：“正则 location” 让步 “普通 location” 的严格精确匹配结果；但覆盖 “普通 location ” 的最大前缀匹配结果。</p>\n<p>例子 1 先普通 location，再正则 location 匹配</p>\n<p>server {<br>\nlisten       9090;<br>\nserver_name  localhost;<br>\nlocation / {<br>\nroot   html;<br>\nindex  index.html index.htm;<br>\ndeny all;<br>\n}<br>\nlocation ~ .html$ {<br>\nallow all;<br>\n}<br>\n}</p>\n<p>例子 2 普通 location 的 “隐式” 严格匹配</p>\n<p>// 在例子 1 的基础上增加精确匹配<br>\n server {<br>\nlisten       9090;<br>\nserver_name  localhost;<br>\nlocation /exact/match.html {<br>\nallow all;<br>\n}<br>\nlocation / {<br>\nroot   html;<br>\nindex  index.html index.htm;<br>\ndeny all;<br>\n}<br>\nlocation ~ .html$ {<br>\nallow all;<br>\n}<br>\n}</p>\n<h1 id=\"正则-location-与编辑顺序\"><a class=\"markdownIt-Anchor\" href=\"#正则-location-与编辑顺序\">#</a> 正则 location 与编辑顺序</h1>\n<p>location 的指令与编辑顺序无关，这句话不全对。对于普通 location 指令，匹配规则是：最大前缀匹配（与顺序无关），如果恰好是严格精确匹配结果或者加有前缀 “^~” 或 “ = ”（符号 “ = ” 只能严格匹配，不能前缀匹配），则停止搜索正则 location ；但对于正则 location 的匹配规则是：按编辑顺序逐个匹配（与顺序有关），只要匹配上，就立即停止后面的搜索。</p>\n<p>server <ruby>\n       listen       9090;\n       server_name  localhost;\n       location ~ \\.html$ {\n           allow all; \n       }  \n       location ~ <rp>【</rp><rt>/prefix/.*\\.html$ {\n           deny all;  \n       </rt><rp>】</rp></ruby><br>\n}<br>\nserver <ruby>\n       listen       9090;\n       server_name  localhost;\n       location ~ <rp>【</rp><rt>/prefix/.*\\.html$ {\n           deny all;  \n       </rt><rp>】</rp></ruby><br>\nlocation ~ .html$ {<br>\nallow all;<br>\n}<br>\n}</p>\n",
            "tags": [
                "教程",
                "nginx"
            ]
        },
        {
            "id": "https://my.durtime.top/posts/0/",
            "url": "https://my.durtime.top/posts/0/",
            "title": "Butterfly添加全局吸底Aplayer教程",
            "date_published": "2022-07-31T11:02:28.000Z",
            "content_html": "<div class=\"note info flat\"><p>以下文章只是教程</p>\n<p>如果部署之后，并没有出现 aplayer , 请确认是否跟足步骤操作或者更换音乐源，多试试。</p>\n<p>如果遇到使用問題，请仔细查看插件文档，或者到插件那裏反饋。</p>\n</div>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>如果你想使用 aplayer，很多人都會推薦安裝 <a href=\"https://github.com/MoePlayer/hexo-tag-aplayer\">hexo-tag-aplayer</a> 這款插件。這款插件通過 Hexo 獨有的標籤外掛，我們可以很方便的寫入一些參數，插件就會幫我們生成對應的 html。如果你只是使用一些簡單的功能，其實無需使用到這個插件，只需以 html 格式書寫就行，不用插件去轉換。</p>\n<p>例如：</p>\n<p>如果使用插件，在 markdown 中要這樣寫</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% meting &quot;000PeZCQ1i4XVs&quot; &quot;tencent&quot; &quot;artist&quot; &quot;theme:#3F51B5&quot; &quot;mutex:true&quot; &quot;preload:auto&quot; %&#125;</span><br></pre></td></tr></table></figure>\n<p>其會被插件渲染為</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;aplayer-uxAIfEUs&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;</span> <span class=\"attr\">data-id</span>=<span class=\"string\">&quot;000PeZCQ1i4XVs&quot;</span> <span class=\"attr\">data-server</span>=<span class=\"string\">&quot;tencent&quot;</span> <span class=\"attr\">data-type</span>=<span class=\"string\">&quot;artist&quot;</span> <span class=\"attr\">data-mode</span>=<span class=\"string\">&quot;circulation&quot;</span> <span class=\"attr\">data-autoplay</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"attr\">data-mutex</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">data-listmaxheight</span>=<span class=\"string\">&quot;340px&quot;</span> <span class=\"attr\">data-preload</span>=<span class=\"string\">&quot;auto&quot;</span> <span class=\"attr\">data-theme</span>=<span class=\"string\">&quot;#3F51B5&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如果我們不想使用插件，就需要在 markdown 中用 html 的格式書寫，同時把主題配置文件中的 <code>aplayerInject</code>  開啟</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;aplayer&quot;</span> <span class=\"attr\">data-id</span>=<span class=\"string\">&quot;000PeZCQ1i4XVs&quot;</span> <span class=\"attr\">data-server</span>=<span class=\"string\">&quot;tencent&quot;</span> <span class=\"attr\">data-type</span>=<span class=\"string\">&quot;artist&quot;</span> <span class=\"attr\">data-mutex</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">data-preload</span>=<span class=\"string\">&quot;auto&quot;</span> <span class=\"attr\">data-theme</span>=<span class=\"string\">&quot;#3F51B5&quot;</span>&gt;</span></span><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>這樣我們就可以不用使用多一個插件，當然這種東西見仁見智，選自己喜歡的就行。</p>\n<p>回到正題，這篇文章將教大家如何在 Butterfly 上使用全局吸底 Aplayer</p>\n<p><img src=\"https://file.crazywong.com/gh/jerryc127/CDN/img/butterfly-aplayer-xidi.gif\" alt=\"aplayer\"></p>\n<h2 id=\"關閉-asset_inject\"><a class=\"markdownIt-Anchor\" href=\"#關閉-asset_inject\">#</a> 關閉  <code>asset_inject</code></h2>\n<div class=\"note info flat\"><p>此步驟適用於安裝了  <code>hexo-tag-aplayer</code>  插件的人</p>\n</div>\n<p>由於需要全局都插入 aplayer 和 meting 資源，為了防止插入重複的資源，需要把 asset_inject 設為  <code>false</code></p>\n<p>在 Hexo 的配置文件中</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">aplayer:</span></span><br><span class=\"line\">  <span class=\"attr\">meting:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">asset_inject:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"開啟主題的-aplayerinject\"><a class=\"markdownIt-Anchor\" href=\"#開啟主題的-aplayerinject\">#</a> 開啟主題的  <code>aplayerInject</code></h2>\n<p>在主題的配置文件中， <code>enable</code>  設為  <code>true</code>  和  <code>per_page</code>  設為  <code>true</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Inject the css and script (aplayer/meting)</span></span><br><span class=\"line\"><span class=\"attr\">aplayerInject:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">per_page:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"插入-aplayer-html\"><a class=\"markdownIt-Anchor\" href=\"#插入-aplayer-html\">#</a> 插入 Aplayer html</h2>\n<p>為了適配 hexo-tag-aplayer，主題內置的 Meting js 仍為 1.2 版本，並非最新的 2.x 版本。</p>\n<p>Aplayer html 例子：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;aplayer no-destroy&quot;</span> <span class=\"attr\">data-id</span>=<span class=\"string\">&quot;60198&quot;</span> <span class=\"attr\">data-server</span>=<span class=\"string\">&quot;netease&quot;</span> <span class=\"attr\">data-type</span>=<span class=\"string\">&quot;playlist&quot;</span> <span class=\"attr\">data-fixed</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">data-autoplay</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span> <span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>參數解釋</p>\n<table>\n<thead>\n<tr>\n<th>option</th>\n<th>default</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>data-id</td>\n<td><strong>require</strong></td>\n<td>song id / playlist id / album id / search keyword</td>\n</tr>\n<tr>\n<td>data-server</td>\n<td><strong>require</strong></td>\n<td>music platform:  <code>netease</code> ,  <code>tencent</code> ,  <code>kugou</code> ,  <code>xiami</code> ,  <code>baidu</code></td>\n</tr>\n<tr>\n<td>data-type</td>\n<td><strong>require</strong></td>\n<td><code>song</code> ,  <code>playlist</code> ,  <code>album</code> ,  <code>search</code> ,  <code>artist</code></td>\n</tr>\n<tr>\n<td>data-fixed</td>\n<td><code>false</code></td>\n<td>enable fixed mode</td>\n</tr>\n<tr>\n<td>data-mini</td>\n<td><code>false</code></td>\n<td>enable mini mode</td>\n</tr>\n<tr>\n<td>data-autoplay</td>\n<td><code>false</code></td>\n<td>audio autoplay</td>\n</tr>\n<tr>\n<td>data-theme</td>\n<td><code>#2980b9</code></td>\n<td>main color</td>\n</tr>\n<tr>\n<td>data-loop</td>\n<td><code>all</code></td>\n<td>player loop play, values: ‘all’, ‘one’, ‘none’</td>\n</tr>\n<tr>\n<td>data-order</td>\n<td><code>list</code></td>\n<td>player play order, values: ‘list’, ‘random’</td>\n</tr>\n<tr>\n<td>data-preload</td>\n<td><code>auto</code></td>\n<td>values: ‘none’, ‘metadata’, ‘auto’</td>\n</tr>\n<tr>\n<td>data-volume</td>\n<td><code>0.7</code></td>\n<td>default volume, notice that player will remember user setting, default volume will not work after user set volume themselves</td>\n</tr>\n<tr>\n<td>data-mutex</td>\n<td><code>true</code></td>\n<td>prevent to play multiple player at the same time, pause other players when this player start play</td>\n</tr>\n<tr>\n<td>data-lrctype</td>\n<td><code>0</code></td>\n<td>lyric type</td>\n</tr>\n<tr>\n<td>data-listfolded</td>\n<td><code>false</code></td>\n<td>indicate whether list should folded at first</td>\n</tr>\n<tr>\n<td>data-listmaxheight</td>\n<td><code>340px</code></td>\n<td>list max height</td>\n</tr>\n<tr>\n<td>data-storagename</td>\n<td><code>metingjs</code></td>\n<td>localStorage key that store player setting</td>\n</tr>\n</tbody>\n</table>\n<div class=\"note info flat\"><p><code>require</code>  代表着這些參數是必須要使用的，其它的參數則可以根據自己需要配置。</p>\n<p>配置全局吸底， <code>data-fixed</code>  和  <code>data-mini</code>  也必須配置，配置為  <code>true</code></p>\n<p>如果使用 Pjax，則在 class 裏需添加  <code>no-destroy</code> ，這樣防止切換頁面時 Aplayer 被銷毀</p>\n</div>\n<p>把   <code>aplayer代碼</code>   插入到主題配置文件的   <code>inject.bottom</code>  去</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">inject:</span></span><br><span class=\"line\">  <span class=\"attr\">head:</span></span><br><span class=\"line\">  <span class=\"attr\">bottom:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">&lt;div</span> <span class=\"string\">class=&quot;aplayer</span> <span class=\"literal\">no</span><span class=\"string\">-destroy&quot;</span> <span class=\"string\">data-id=&quot;60198&quot;</span> <span class=\"string\">data-server=&quot;netease&quot;</span> <span class=\"string\">data-type=&quot;playlist&quot;</span> <span class=\"string\">data-fixed=&quot;true&quot;</span> <span class=\"string\">data-autoplay=&quot;true&quot;&gt;</span> <span class=\"string\">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>\n<p>運行 Hexo 就可以看到網頁左下角出現了 Aplayer</p>\n<p>最後，如果你想切換頁面時，音樂不會中斷。請把主題配置文件的  <code>pjax</code>  設為  <code>true</code></p>\n",
            "tags": [
                "教程",
                "Hexo",
                "主題",
                "butterfly",
                "Aplayer"
            ]
        },
        {
            "id": "https://my.durtime.top/posts/3c50d03d/",
            "url": "https://my.durtime.top/posts/3c50d03d/",
            "title": "Markdown语法",
            "date_published": "2022-05-29T14:36:02.000Z",
            "content_html": "<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\">#</a> 简介</h1>\n<p>Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown 支持嵌入 html 标签。</p>\n<p><u>注意：Markdown 使用 #、+、* 等符号来标记， 符号后面必须跟上 至少 1 个 空格才有效！</u></p>\n<h1 id=\"markdown的常用语法\"><a class=\"markdownIt-Anchor\" href=\"#markdown的常用语法\">#</a> Markdown 的常用语法</h1>\n<p>标题<br>\n Markdown 标题支持两种形式：</p>\n<p>1、用 #标记</p>\n<p>在 标题开头 加上 1~6 个 #，依次代表一级标题、二级标题… 六级标题</p>\n<h1 id=\"一级标题\"><a class=\"markdownIt-Anchor\" href=\"#一级标题\">#</a> 一级标题</h1>\n<h2 id=\"二级标题\"><a class=\"markdownIt-Anchor\" href=\"#二级标题\">#</a> 二级标题</h2>\n<h3 id=\"三级标题\"><a class=\"markdownIt-Anchor\" href=\"#三级标题\">#</a> 三级标题</h3>\n<h5 id=\"四级标题\"><a class=\"markdownIt-Anchor\" href=\"#四级标题\">#</a> 四级标题</h5>\n<h6 id=\"五级标题\"><a class=\"markdownIt-Anchor\" href=\"#五级标题\">#</a> 五级标题</h6>\n<h6 id=\"六级标题\"><a class=\"markdownIt-Anchor\" href=\"#六级标题\">#</a> 六级标题</h6>\n<p>2、用 = 和 - 标记</p>\n<p>在 标题底下 加上任意个 = 代表一级标题，- 代表二级标题</p>\n<h1 id=\"一级标题-2\"><a class=\"markdownIt-Anchor\" href=\"#一级标题-2\">#</a> 一级标题</h1>\n<h2 id=\"二级标题-2\"><a class=\"markdownIt-Anchor\" href=\"#二级标题-2\">#</a> 二级标题</h2>\n<p>效果如下：</p>\n<p>一级标题<br>\n二级标题<br>\n三级标题<br>\n四级标题<br>\n五级标题<br>\n六级标题<br>\n列表<br>\n Markdown 支持有序列表和无序列表。</p>\n<p>无序列表使用 -、+ 和 * 作为列表标记：</p>\n<ul>\n<li>Red</li>\n<li>Green</li>\n<li>Blue</li>\n</ul>\n<ul>\n<li>Red</li>\n<li>Green</li>\n<li>Blue</li>\n</ul>\n<ul>\n<li>Red</li>\n<li>Green</li>\n<li>Blue<br>\n 效果如下：</li>\n</ul>\n<p>Red<br>\nGreen<br>\nBlue<br>\n 有序列表则使用数字加英文句点。来表示：</p>\n<ol>\n<li>Red</li>\n<li>Green</li>\n<li>Blue<br>\n 效果如下：</li>\n</ol>\n<p>Red<br>\nGreen<br>\nBlue<br>\n 引用<br>\n引用以 &gt; 来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语法。</p>\n<p>常见的引用写法：</p>\n<blockquote>\n<p>这是一段引用    // 在 <code>&gt;</code>  后面有 1 个空格</p>\n<pre><code>这是引用的代码块形式    //在`&gt;`后面有 5 个空格\n</code></pre>\n<p>代码例子：</p>\n</blockquote>\n<pre><code>protected void onCreate(Bundle savedInstanceState) &#123;\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n&#125;\n</code></pre>\n<blockquote>\n<p>一级引用</p>\n<blockquote>\n<p>二级引用</p>\n<blockquote>\n<p>三级引用</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<h4 id=\"这是一个四级标题\"><a class=\"markdownIt-Anchor\" href=\"#这是一个四级标题\">#</a> 这是一个四级标题</h4>\n<ol>\n<li>这是第一行列表项</li>\n<li>这是第二行列表项<br>\n效果如下：</li>\n</ol>\n</blockquote>\n<p>这是一段引用</p>\n<p>这是引用的代码块形式    // 在 <code>&gt;</code>  后面有 5 个空格<br>\n代码例子：</p>\n<p>protected void onCreate(Bundle savedInstanceState) {<br>\nsuper.onCreate(savedInstanceState);<br>\nsetContentView(R.layout.activity_main);<br>\n}<br>\n 一级引用</p>\n<p>二级引用</p>\n<p>三级引用</p>\n<p>这是一个四级标题<br>\n这是第一行列表项<br>\n这是第二行列表项<br>\n以下是分割线</p>\n<p>强调<br>\n两个<em>或 - 代表加粗，一个</em>或 - 代表斜体，~~ 代表删除。</p>\n<p><strong>加粗文本</strong> 或者 <strong>加粗文本</strong></p>\n<p><em>斜体文本</em>  或者_斜体文本_</p>\n<p><s>删除文本</s><br>\n效果如下：</p>\n<p>加粗文本 或者 加粗文本</p>\n<p>斜体文本 或者 斜体文本</p>\n<p>删除文本</p>\n<p>图片与链接<br>\n图片与链接的语法很像，区别在一个！号。二者格式：</p>\n<p>图片：<img src=\"\" alt=\"\">    <img src=\"%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80\" alt=\"图片文本(可忽略)\"></p>\n<p>链接：<a href=\"\"></a>     <a href=\"%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80\">链接文本</a><br>\n链接又分为行内式、参考式和 自动链接：</p>\n<p>这是行内式链接：<a href=\"http://connorlin.github.io\">ConnorLin’s Blog</a>。</p>\n<p>这是参考式链接：<a href=\"http://connorlin.github.io/\" title=\"ConnorLin's Blog\">ConnorLin’s Blog</a>，其中 url 为链接标记，可置于文中任意位置。</p>\n<p>链接标记格式为：[链接标记文本]:  链接地址  链接 title (可忽略)</p>\n<p>这是自动链接：直接使用 <code>&lt;&gt;</code>  括起来<a href=\"http://connorlin.github.io\"> http://connorlin.github.io</a></p>\n<p>这是图片：<img src=\"https://connorlin.github.io/images/avatar.jpg\" alt=\"\"></p>\n<h2 id=\"代码\"><a class=\"markdownIt-Anchor\" href=\"#代码\">#</a> 代码</h2>\n<p>代码分为行内代码和代码块。</p>\n<p>行内代码使用  <code>代码</code>  标识，可嵌入文字中</p>\n<p>代码块使用 4 个空格或 ``` 标识</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里是代码</span><br></pre></td></tr></table></figure>\n<p>代码语法高亮在 ``` 后面加上空格和语言名称即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注意语言前面有空格</span><br><span class=\"line\">这里是代码</span><br></pre></td></tr></table></figure>\n<p>例如：</p>\n<p>这是行内代码 <code>onCreate(Bundle savedInstanceState)</code>  的例子。</p>\n<p>这是代码块和语法高亮：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意java前面有空格</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p>这是行内代码 onCreate (Bundle savedInstanceState) 的例子。</p>\n<p>这是代码块和语法高亮：</p>\n<p>// 注意 java 前面有空格<br>\n protected void onCreate (Bundle savedInstanceState) {<br>\nsuper.onCreate(savedInstanceState);<br>\nsetContentView(R.layout.activity_main);<br>\n}<br>\n 表格<br>\n表格对齐格式</p>\n<p>居左：:----<br>\n 居中：:----: 或 -----<br>\n 居右：----:<br>\n 例子：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">标题</th>\n<th style=\"text-align:center\">标题</th>\n<th style=\"text-align:right\">标题</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">居左测试文本</td>\n<td style=\"text-align:center\">居中测试文本</td>\n<td style=\"text-align:right\">居右测试文本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">居左测试文本 1</td>\n<td style=\"text-align:center\">居中测试文本 2</td>\n<td style=\"text-align:right\">居右测试文本 3</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">居左测试文本 11</td>\n<td style=\"text-align:center\">居中测试文本 22</td>\n<td style=\"text-align:right\">居右测试文本 33</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">居左测试文本 111</td>\n<td style=\"text-align:center\">居中测试文本 222</td>\n<td style=\"text-align:right\">居右测试文本 333</td>\n</tr>\n</tbody>\n</table>\n<p>效果如下：</p>\n<p>标题\t标题\t标题<br>\n居左测试文本\t居中测试文本\t居右测试文本<br>\n居左测试文本 1\t居中测试文本 2\t居右测试文本 3<br>\n 居左测试文本 11\t居中测试文本 22\t居右测试文本 33<br>\n 居左测试文本 111\t居中测试文本 222\t居右测试文本 333<br>\n 分隔线<br>\n在一行中用三个以上的 *、-、_来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">***</span><br><span class=\"line\">---</span><br><span class=\"line\">___</span><br><span class=\"line\"></span><br><span class=\"line\">* * *</span><br></pre></td></tr></table></figure>\n<p>效果:</p>\n<hr>\n<hr>\n<hr>\n<hr>\n<p>效果均为一条分割线：</p>\n<p>换行<br>\n在行尾添加两个空格加回车表示换行：</p>\n<p>这是一行后面加两个空格  换行<br>\n效果如下：</p>\n<p>这是一行后面加两个空格<br>\n换行</p>\n<p>脚注 (注解)<br>\n 使用 [^] 来定义脚注：</p>\n<p>这是一个脚注的例子<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></p>\n<p>这是一个脚注的例子 [1]</p>\n<p>常用弥补 Markdown 的 Html 标签<br>\n字体</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;font face=&quot;微软雅黑&quot; color=&quot;red&quot; size=&quot;6&quot;&gt;字体及字体颜色和大小&lt;/font&gt;</span><br><span class=\"line\">&lt;font color=&quot;#0000ff&quot;&gt;字体颜色&lt;/font&gt;</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><font face=\"微软雅黑\" color=\"red\" size=\"6\">字体及字体颜色和大小</font><br>\n<font color=\"#0000ff\">字体颜色</font></p>\n<p>换行<br>\n使用 html 标签 <code>&lt;br/&gt;</code> <br/>换行</p>\n<p>文本对齐方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p align=&quot;left&quot;&gt;居左文本&lt;/p&gt;</span><br><span class=\"line\">&lt;p align=&quot;center&quot;&gt;居中文本&lt;/p&gt;</span><br><span class=\"line\">&lt;p align=&quot;right&quot;&gt;居右文本&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p align=\"left\">居左文本</p>\n<p align=\"center\">居中文本</p>\n<p align=\"right\">居右文本</p>\n<p>下划线</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;u&gt;下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><u>下划线文本</u></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>这里是脚注<br>\n效果如下： <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
            "tags": [
                "教程",
                "Markdown语法"
            ]
        },
        {
            "id": "https://my.durtime.top/posts/55bce094/",
            "url": "https://my.durtime.top/posts/55bce094/",
            "title": "Docker实用篇",
            "date_published": "2022-05-28T14:31:46.000Z",
            "content_html": "<h1 id=\"docker实用篇\"><a class=\"markdownIt-Anchor\" href=\"#docker实用篇\">#</a> Docker 实用篇</h1>\n<h1 id=\"0学习目标\"><a class=\"markdownIt-Anchor\" href=\"#0学习目标\">#</a> 0. 学习目标</h1>\n<h1 id=\"1初识docker\"><a class=\"markdownIt-Anchor\" href=\"#1初识docker\">#</a> 1. 初识 Docker</h1>\n<h2 id=\"11什么是docker\"><a class=\"markdownIt-Anchor\" href=\"#11什么是docker\">#</a> 1.1. 什么是 Docker</h2>\n<p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p>\n<ul>\n<li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li>\n<li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li>\n</ul>\n<h3 id=\"111应用部署的环境问题\"><a class=\"markdownIt-Anchor\" href=\"#111应用部署的环境问题\">#</a> 1.1.1. 应用部署的环境问题</h3>\n<p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p>\n<ul>\n<li>\n<p>依赖关系复杂，容易出现兼容性问题</p>\n</li>\n<li>\n<p>开发、测试、生产环境有差异</p>\n</li>\n</ul>\n<p><img src=\"/assets/image-20210731141907366.png\" alt=\"image-20210731141907366\"></p>\n<p>例如一个项目中，部署时需要依赖于 node.js、Redis、RabbitMQ、MySQL 等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p>\n<h3 id=\"112docker解决依赖兼容问题\"><a class=\"markdownIt-Anchor\" href=\"#112docker解决依赖兼容问题\">#</a> 1.1.2.Docker 解决依赖兼容问题</h3>\n<p>而 Docker 确巧妙的解决了这些问题，Docker 是如何实现的呢？</p>\n<p>Docker 为了解决依赖的兼容问题的，采用了两个手段：</p>\n<ul>\n<li>\n<p>将应用的 Libs（函数库）、Deps（依赖）、配置与应用一起打包</p>\n</li>\n<li>\n<p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p>\n</li>\n</ul>\n<p><img src=\"/assets/image-20210731142219735.png\" alt=\"image-20210731142219735\"></p>\n<p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的 Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p>\n<p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p>\n<h3 id=\"113docker解决操作系统环境差异\"><a class=\"markdownIt-Anchor\" href=\"#113docker解决操作系统环境差异\">#</a> 1.1.3.Docker 解决操作系统环境差异</h3>\n<p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个 Ubuntu 操作系统为例，结构如下：</p>\n<p><img src=\"/assets/image-20210731143401460.png\" alt=\"image-20210731143401460\"></p>\n<p>结构包括：</p>\n<ul>\n<li>计算机硬件：例如 CPU、内存、磁盘等</li>\n<li>系统内核：所有 Linux 发行版的内核都是 Linux，例如 CentOS、Ubuntu、Fedora 等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li>\n<li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li>\n</ul>\n<p>应用于计算机交互的流程如下：</p>\n<p>1）应用调用操作系统应用（函数库），实现各种功能</p>\n<p>2）系统函数库是对内核指令集的封装，会调用内核指令</p>\n<p>3）内核指令操作计算机硬件</p>\n<p>Ubuntu 和 CentOSpringBoot 都是基于 Linux 内核，无非是系统应用不同，提供的函数库有差异：</p>\n<p><img src=\"/assets/image-20210731144304990.png\" alt=\"image-20210731144304990\"></p>\n<p>此时，如果将一个 Ubuntu 版本的 MySQL 应用安装到 CentOS 系统，MySQL 在调用 Ubuntu 函数库时，会发现找不到或者不匹配，就会报错了：</p>\n<p><img src=\"/assets/image-20210731144458680.png\" alt=\"image-20210731144458680\"></p>\n<p>Docker 如何解决不同系统环境的问题？</p>\n<ul>\n<li>Docker 将用户程序与所需要调用的系统 (比如 Ubuntu) 函数库一起打包</li>\n<li>Docker 运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的 Linux 内核来运行</li>\n</ul>\n<p>如图：</p>\n<p><img src=\"/assets/image-20210731144820638.png\" alt=\"image-20210731144820638\"></p>\n<h3 id=\"114小结\"><a class=\"markdownIt-Anchor\" href=\"#114小结\">#</a> 1.1.4. 小结</h3>\n<p>Docker 如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p>\n<ul>\n<li>Docker 允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li>\n<li>Docker 应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li>\n</ul>\n<p>Docker 如何解决开发、测试、生产环境有差异的问题？</p>\n<ul>\n<li>Docker 镜像中包含完整运行环境，包括系统函数库，仅依赖系统的 Linux 内核，因此可以在任意 Linux 操作系统上运行</li>\n</ul>\n<p>Docker 是一个快速交付应用、运行应用的技术，具备下列优势：</p>\n<ul>\n<li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意 Linux 操作系统</li>\n<li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li>\n<li>启动、移除都可以通过一行命令完成，方便快捷</li>\n</ul>\n<h2 id=\"12docker和虚拟机的区别\"><a class=\"markdownIt-Anchor\" href=\"#12docker和虚拟机的区别\">#</a> 1.2.Docker 和虚拟机的区别</h2>\n<p>Docker 可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p>\n<p>两者有什么差异呢？</p>\n<p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的 Ubuntu 应用了。</p>\n<p><strong>Docker</strong> 仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p>\n<p><img src=\"/assets/image-20210731145914960.png\" alt=\"image-20210731145914960\"></p>\n<p>对比来看：</p>\n<p><img src=\"/assets/image-20210731152243765.png\" alt=\"image-20210731152243765\"></p>\n<p>小结：</p>\n<p>Docker 和虚拟机的差异：</p>\n<ul>\n<li>\n<p>docker 是一个系统进程；虚拟机是在操作系统中的操作系统</p>\n</li>\n<li>\n<p>docker 体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p>\n</li>\n</ul>\n<h2 id=\"13docker架构\"><a class=\"markdownIt-Anchor\" href=\"#13docker架构\">#</a> 1.3.Docker 架构</h2>\n<h3 id=\"131镜像和容器\"><a class=\"markdownIt-Anchor\" href=\"#131镜像和容器\">#</a> 1.3.1. 镜像和容器</h3>\n<p>Docker 中有几个重要的概念：</p>\n<p><strong>镜像（Image）</strong>：Docker 将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p>\n<p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是 Docker 会给容器进程做隔离，对外不可见。</p>\n<p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p>\n<p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p>\n<p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p>\n<p><img src=\"/assets/image-20210731153059464.png\" alt=\"image-20210731153059464\"></p>\n<p>例如你下载了一个 QQ，如果我们将 QQ 在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成 QQ 镜像。然后你可以启动多次，双开、甚至三开 QQ，跟多个妹子聊天。</p>\n<h3 id=\"132dockerhub\"><a class=\"markdownIt-Anchor\" href=\"#132dockerhub\">#</a> 1.3.2.DockerHub</h3>\n<p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如 Redis、MySQL 镜像放到网络上，共享使用，就像 GitHub 的代码共享一样。</p>\n<ul>\n<li>\n<p>DockerHub：DockerHub 是一个官方的 Docker 镜像的托管平台。这样的平台称为 Docker Registry。</p>\n</li>\n<li>\n<p>国内也有类似于 DockerHub 的公开服务，比如 <a href=\"https://c.163yun.com/hub\">网易云镜像服务</a>、<a href=\"https://cr.console.aliyun.com/\">阿里云镜像库</a>等。</p>\n</li>\n</ul>\n<p>我们一方面可以将自己的镜像共享到 DockerHub，另一方面也可以从 DockerHub 拉取镜像：</p>\n<p><img src=\"/assets/image-20210731153743354.png\" alt=\"image-20210731153743354\"></p>\n<h3 id=\"133docker架构\"><a class=\"markdownIt-Anchor\" href=\"#133docker架构\">#</a> 1.3.3.Docker 架构</h3>\n<p>我们要使用 Docker 来操作镜像、容器，就必须要安装 Docker。</p>\n<p>Docker 是一个 CS 架构的程序，由两部分组成：</p>\n<ul>\n<li>\n<p>服务端 (server)：Docker 守护进程，负责处理 Docker 指令，管理镜像、容器等</p>\n</li>\n<li>\n<p>客户端 (client)：通过命令或 RestAPI 向 Docker 服务端发送指令。可以在本地或远程向服务端发送指令。</p>\n</li>\n</ul>\n<p>如图：</p>\n<p><img src=\"/assets/image-20210731154257653.png\" alt=\"image-20210731154257653\"></p>\n<h3 id=\"134小结\"><a class=\"markdownIt-Anchor\" href=\"#134小结\">#</a> 1.3.4. 小结</h3>\n<p>镜像：</p>\n<ul>\n<li>将应用程序及其依赖、环境、配置打包在一起</li>\n</ul>\n<p>容器：</p>\n<ul>\n<li>镜像运行起来就是容器，一个镜像可以运行多个容器</li>\n</ul>\n<p>Docker 结构：</p>\n<ul>\n<li>\n<p>服务端：接收命令或远程请求，操作镜像或容器</p>\n</li>\n<li>\n<p>客户端：发送命令或者请求到 Docker 服务端</p>\n</li>\n</ul>\n<p>DockerHub：</p>\n<ul>\n<li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为 DockerRegistry</li>\n</ul>\n<h2 id=\"14安装docker\"><a class=\"markdownIt-Anchor\" href=\"#14安装docker\">#</a> 1.4. 安装 Docker</h2>\n<p>企业部署一般都是采用 Linux 操作系统，而其中又数 CentOS 发行版占比最多，因此我们在 CentOS 下安装 Docker。参考课前资料中的文档：</p>\n<p><img src=\"/assets/image-20210731155002425.png\" alt=\"image-20210731155002425\"></p>\n<h1 id=\"2docker的基本操作\"><a class=\"markdownIt-Anchor\" href=\"#2docker的基本操作\">#</a> 2.Docker 的基本操作</h1>\n<h2 id=\"21镜像操作\"><a class=\"markdownIt-Anchor\" href=\"#21镜像操作\">#</a> 2.1. 镜像操作</h2>\n<h3 id=\"211镜像名称\"><a class=\"markdownIt-Anchor\" href=\"#211镜像名称\">#</a> 2.1.1. 镜像名称</h3>\n<p>首先来看下镜像的名称组成：</p>\n<ul>\n<li>镜名称一般分两部分组成：[repository]:[tag]。</li>\n<li>在没有指定 tag 时，默认是 latest，代表最新版本的镜像</li>\n</ul>\n<p>如图：</p>\n<p><img src=\"/assets/image-20210731155141362.png\" alt=\"image-20210731155141362\"></p>\n<p>这里的 mysql 就是 repository，5.7 就是 tag，合一起就是镜像名称，代表 5.7 版本的 MySQL 镜像。</p>\n<h3 id=\"212镜像命令\"><a class=\"markdownIt-Anchor\" href=\"#212镜像命令\">#</a> 2.1.2. 镜像命令</h3>\n<p>常见的镜像操作命令如图：</p>\n<p><img src=\"/assets/image-20210731155649535.png\" alt=\"image-20210731155649535\"></p>\n<h3 id=\"213案例1-拉取-查看镜像\"><a class=\"markdownIt-Anchor\" href=\"#213案例1-拉取-查看镜像\">#</a> 2.1.3. 案例 1 - 拉取、查看镜像</h3>\n<p>需求：从 DockerHub 中拉取一个 nginx 镜像并查看</p>\n<p>1）首先去镜像仓库搜索 nginx 镜像，比如<a href=\"https://hub.docker.com/\"> DockerHub</a>:</p>\n<p><img src=\"/assets/image-20210731155844368.png\" alt=\"image-20210731155844368\"></p>\n<p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p>\n<p><img src=\"/assets/image-20210731155856199.png\" alt=\"image-20210731155856199\"></p>\n<p>3）通过命令：docker images 查看拉取到的镜像</p>\n<p><img src=\"/assets/image-20210731155903037.png\" alt=\"image-20210731155903037\"></p>\n<h3 id=\"214案例2-保存-导入镜像\"><a class=\"markdownIt-Anchor\" href=\"#214案例2-保存-导入镜像\">#</a> 2.1.4. 案例 2 - 保存、导入镜像</h3>\n<p>需求：利用 docker save 将 nginx 镜像导出磁盘，然后再通过 load 加载回来</p>\n<p>1）利用 docker xx --help 命令查看 docker save 和 docker load 的语法</p>\n<p>例如，查看 save 命令用法，可以输入命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<p><img src=\"/assets/image-20210731161104732.png\" alt=\"image-20210731161104732\"></p>\n<p>命令格式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save -o [保存的目标文件名称] [镜像名称]</span><br></pre></td></tr></table></figure>\n<p>2）使用 docker save 导出镜像到磁盘</p>\n<p>运行命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure>\n<p>结果如图：</p>\n<p><img src=\"/assets/image-20210731161354344.png\" alt=\"image-20210731161354344\"></p>\n<p>3）使用 docker load 加载镜像</p>\n<p>先删除本地的 nginx 镜像：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rmi nginx:latest</span><br></pre></td></tr></table></figure>\n<p>然后运行命令，加载本地文件：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker load -i nginx.tar</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<p><img src=\"/assets/image-20210731161746245.png\" alt=\"image-20210731161746245\"></p>\n<h3 id=\"215练习\"><a class=\"markdownIt-Anchor\" href=\"#215练习\">#</a> 2.1.5. 练习</h3>\n<p>需求：去 DockerHub 搜索并拉取一个 Redis 镜像</p>\n<p>目标：</p>\n<p>1）去 DockerHub 搜索 Redis 镜像</p>\n<p>2）查看 Redis 镜像的名称和版本</p>\n<p>3）利用 docker pull 命令拉取镜像</p>\n<p>4）利用 docker save 命令将 redis:latest 打包为一个 redis.tar 包</p>\n<p>5）利用 docker rmi 删除本地的 redis:latest</p>\n<p>6）利用 docker load 重新加载 redis.tar 文件</p>\n<h2 id=\"22容器操作\"><a class=\"markdownIt-Anchor\" href=\"#22容器操作\">#</a> 2.2. 容器操作</h2>\n<h3 id=\"221容器相关命令\"><a class=\"markdownIt-Anchor\" href=\"#221容器相关命令\">#</a> 2.2.1. 容器相关命令</h3>\n<p>容器操作的命令如图：</p>\n<p><img src=\"/assets/image-20210731161950495.png\" alt=\"image-20210731161950495\"></p>\n<p>容器保护三个状态：</p>\n<ul>\n<li>运行：进程正常运行</li>\n<li>暂停：进程暂停，CPU 不再运行，并不释放内存</li>\n<li>停止：进程终止，回收进程占用的内存、CPU 等资源</li>\n</ul>\n<p>其中：</p>\n<ul>\n<li>\n<p>docker run：创建并运行一个容器，处于运行状态</p>\n</li>\n<li>\n<p>docker pause：让一个运行的容器暂停</p>\n</li>\n<li>\n<p>docker unpause：让一个容器从暂停状态恢复运行</p>\n</li>\n<li>\n<p>docker stop：停止一个运行的容器</p>\n</li>\n<li>\n<p>docker start：让一个停止的容器再次运行</p>\n</li>\n<li>\n<p>docker rm：删除一个容器</p>\n</li>\n</ul>\n<h3 id=\"222案例-创建并运行一个容器\"><a class=\"markdownIt-Anchor\" href=\"#222案例-创建并运行一个容器\">#</a> 2.2.2. 案例 - 创建并运行一个容器</h3>\n<p>创建并运行 nginx 容器的命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>\n<p>命令解读：</p>\n<ul>\n<li>docker run ：创建并运行一个容器</li>\n<li>–name : 给容器起一个名字，比如叫做 mn</li>\n<li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li>\n<li>-d：后台运行容器</li>\n<li>nginx：镜像名称，例如 nginx</li>\n</ul>\n<p>这里的 <code>-p</code>  参数，是将容器端口映射到宿主机端口。</p>\n<p>默认情况下，容器是隔离环境，我们直接访问宿主机的 80 端口，肯定访问不到容器中的 nginx。</p>\n<p>现在，将容器的 80 与宿主机的 80 关联起来，当我们访问宿主机的 80 端口时，就会被映射到容器的 80，这样就能访问到 nginx 了：</p>\n<p><img src=\"/assets/image-20210731163255863.png\" alt=\"image-20210731163255863\"></p>\n<h3 id=\"223案例-进入容器修改文件\"><a class=\"markdownIt-Anchor\" href=\"#223案例-进入容器修改文件\">#</a> 2.2.3. 案例 - 进入容器，修改文件</h3>\n<p><strong>需求</strong>：进入 Nginx 容器，修改 HTML 文件内容，添加 “传智教育欢迎您”</p>\n<p><strong>提示</strong>：进入容器要用到 docker exec 命令。</p>\n<p><strong>步骤</strong>：</p>\n<p>1）进入容器。进入我们刚刚创建的 nginx 容器的命令为：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it mn bash</span><br></pre></td></tr></table></figure>\n<p>命令解读：</p>\n<ul>\n<li>\n<p>docker exec ：进入容器内部，执行一个命令</p>\n</li>\n<li>\n<p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p>\n</li>\n<li>\n<p>mn ：要进入的容器的名称</p>\n</li>\n<li>\n<p>bash：进入容器后执行的命令，bash 是一个 linux 终端交互命令</p>\n</li>\n</ul>\n<p>2）进入 nginx 的 HTML 所在目录 /usr/share/nginx/html</p>\n<p>容器内部会模拟一个独立的 Linux 文件系统，看起来如同一个 linux 服务器一样：</p>\n<p><img src=\"/assets/image-20210731164159811.png\" alt=\"image-20210731164159811\"></p>\n<p>nginx 的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的 html 文件。</p>\n<p>查看 DockerHub 网站中的 nginx 页面，可以知道 nginx 的 html 目录位置在 <code>/usr/share/nginx/html</code></p>\n<p>我们执行命令，进入该目录：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/share/nginx/html</span><br></pre></td></tr></table></figure>\n<p>查看目录下文件：</p>\n<p><img src=\"/assets/image-20210731164455818.png\" alt=\"image-20210731164455818\"></p>\n<p>3）修改 index.html 的内容</p>\n<p>容器内没有 vi 命令，无法直接修改，我们用下面的命令来修改：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -i -e <span class=\"string\">&#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27;</span> -e <span class=\"string\">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html</span><br></pre></td></tr></table></figure>\n<p>在浏览器访问自己的虚拟机地址，例如我的是：<a href=\"http://192.168.150.101\">http://192.168.150.101</a>，即可看到结果：</p>\n<p><img src=\"/assets/image-20210731164717604.png\" alt=\"image-20210731164717604\"></p>\n<h3 id=\"224小结\"><a class=\"markdownIt-Anchor\" href=\"#224小结\">#</a> 2.2.4. 小结</h3>\n<p>docker run 命令的常见参数有哪些？</p>\n<ul>\n<li>–name：指定容器名称</li>\n<li>-p：指定端口映射</li>\n<li>-d：让容器后台运行</li>\n</ul>\n<p>查看容器日志的命令：</p>\n<ul>\n<li>docker logs</li>\n<li>添加 -f 参数可以持续查看日志</li>\n</ul>\n<p>查看容器状态：</p>\n<ul>\n<li>docker ps</li>\n<li>docker ps -a 查看所有容器，包括已经停止的</li>\n</ul>\n<h2 id=\"23数据卷容器数据管理\"><a class=\"markdownIt-Anchor\" href=\"#23数据卷容器数据管理\">#</a> 2.3. 数据卷（容器数据管理）</h2>\n<p>在之前的 nginx 案例中，修改 nginx 的 html 页面时，需要进入 nginx 内部。并且因为没有编辑器，修改文件也很麻烦。</p>\n<p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p>\n<p><img src=\"/assets/image-20210731172440275.png\" alt=\"image-20210731172440275\"></p>\n<p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p>\n<h3 id=\"231什么是数据卷\"><a class=\"markdownIt-Anchor\" href=\"#231什么是数据卷\">#</a> 2.3.1. 什么是数据卷</h3>\n<p>** 数据卷（volume）** 是一个虚拟目录，指向宿主机文件系统中的某个目录。</p>\n<p><img src=\"/assets/image-20210731173541846.png\" alt=\"image-20210731173541846\"></p>\n<p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p>\n<p>这样，我们操作宿主机的 /var/lib/docker/volumes/html 目录，就等于操作容器内的 /usr/share/nginx/html 目录了</p>\n<h3 id=\"232数据集操作命令\"><a class=\"markdownIt-Anchor\" href=\"#232数据集操作命令\">#</a> 2.3.2. 数据集操作命令</h3>\n<p>数据卷操作的基本语法如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker volume [COMMAND]</span><br></pre></td></tr></table></figure>\n<p>docker volume 命令是数据卷操作，根据命令后跟随的 command 来确定下一步的操作：</p>\n<ul>\n<li>create 创建一个 volume</li>\n<li>inspect 显示一个或多个 volume 的信息</li>\n<li>ls 列出所有的 volume</li>\n<li>prune 删除未使用的 volume</li>\n<li>rm 删除一个或多个指定的 volume</li>\n</ul>\n<h3 id=\"233创建和查看数据卷\"><a class=\"markdownIt-Anchor\" href=\"#233创建和查看数据卷\">#</a> 2.3.3. 创建和查看数据卷</h3>\n<p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p>\n<p>① 创建数据卷</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker volume create html</span><br></pre></td></tr></table></figure>\n<p>② 查看所有数据</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker volume <span class=\"built_in\">ls</span></span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<p><img src=\"/assets/image-20210731173746910.png\" alt=\"image-20210731173746910\"></p>\n<p>③ 查看数据卷详细信息卷</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker volume inspect html</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<p><img src=\"/assets/image-20210731173809877.png\" alt=\"image-20210731173809877\"></p>\n<p>可以看到，我们创建的 html 这个数据卷关联的宿主机目录为 <code>/var/lib/docker/volumes/html/_data</code>  目录。</p>\n<p><strong>小结</strong>：</p>\n<p>数据卷的作用：</p>\n<ul>\n<li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li>\n</ul>\n<p>数据卷操作：</p>\n<ul>\n<li>docker volume create：创建数据卷</li>\n<li>docker volume ls：查看所有数据卷</li>\n<li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li>\n<li>docker volume rm：删除指定数据卷</li>\n<li>docker volume prune：删除所有未使用的数据卷</li>\n</ul>\n<h3 id=\"234挂载数据卷\"><a class=\"markdownIt-Anchor\" href=\"#234挂载数据卷\">#</a> 2.3.4. 挂载数据卷</h3>\n<p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run \\</span><br><span class=\"line\">  --name mn \\</span><br><span class=\"line\">  -v html:/root/html \\</span><br><span class=\"line\">  -p 8080:80</span><br><span class=\"line\">  nginx \\</span><br></pre></td></tr></table></figure>\n<p>这里的 - v 就是挂载数据卷的命令：</p>\n<ul>\n<li><code>-v html:/root/htm</code>  ：把 html 数据卷挂载到容器内的 /root/html 这个目录中</li>\n</ul>\n<h3 id=\"235案例-给nginx挂载数据卷\"><a class=\"markdownIt-Anchor\" href=\"#235案例-给nginx挂载数据卷\">#</a> 2.3.5. 案例 - 给 nginx 挂载数据卷</h3>\n<p><strong>需求</strong>：创建一个 nginx 容器，修改容器内的 html 目录内的 index.html 内容</p>\n<p><strong>分析</strong>：上个案例中，我们进入 nginx 容器内部，已经知道 nginx 的 html 目录所在位置 /usr/share/nginx/html ，我们需要把这个目录挂载到 html 这个数据卷上，方便操作其中的内容。</p>\n<p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p>\n<p>步骤：</p>\n<p>① 创建容器并挂载数据卷到容器内的 HTML 目录</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>\n<p>② 进入 html 数据卷所在位置，并修改 HTML 内容</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看html数据卷的位置</span></span><br><span class=\"line\">docker volume inspect html</span><br><span class=\"line\"><span class=\"comment\"># 进入该目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class=\"line\"><span class=\"comment\"># 修改文件</span></span><br><span class=\"line\">vi index.html</span><br></pre></td></tr></table></figure>\n<h3 id=\"236案例-给mysql挂载本地目录\"><a class=\"markdownIt-Anchor\" href=\"#236案例-给mysql挂载本地目录\">#</a> 2.3.6. 案例 - 给 MySQL 挂载本地目录</h3>\n<p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p>\n<ul>\n<li>带数据卷模式：宿主机目录 --&gt; 数据卷 —&gt; 容器内目录</li>\n<li>直接挂载模式：宿主机目录 —&gt; 容器内目录</li>\n</ul>\n<p>如图：</p>\n<p><img src=\"/assets/image-20210731175155453.png\" alt=\"image-20210731175155453\"></p>\n<p><strong>语法</strong>：</p>\n<p>目录挂载与数据卷挂载的语法是类似的：</p>\n<ul>\n<li>-v [宿主机目录]:[容器内目录]</li>\n<li>-v [宿主机文件]:[容器内文件]</li>\n</ul>\n<p><strong>需求</strong>：创建并运行一个 MySQL 容器，将宿主机目录直接挂载到容器</p>\n<p>实现思路如下：</p>\n<p>1）在将课前资料中的 mysql.tar 文件上传到虚拟机，通过 load 命令加载为镜像</p>\n<p>2）创建目录 /tmp/mysql/data</p>\n<p>3）创建目录 /tmp/mysql/conf，将课前资料提供的 hmy.cnf 文件上传到 /tmp/mysql/conf</p>\n<p>4）去 DockerHub 查阅资料，创建并运行 MySQL 容器，要求：</p>\n<p>① 挂载 /tmp/mysql/data 到 mysql 容器内数据存储目录</p>\n<p>② 挂载 /tmp/mysql/conf/hmy.cnf 到 mysql 容器的配置文件</p>\n<p>③ 设置 MySQL 密码</p>\n<h3 id=\"237小结\"><a class=\"markdownIt-Anchor\" href=\"#237小结\">#</a> 2.3.7. 小结</h3>\n<p>docker run 的命令中通过 -v 参数挂载文件或目录到容器中：</p>\n<ul>\n<li>-v volume 名称：容器内目录</li>\n<li>-v 宿主机文件：容器内文</li>\n<li>-v 宿主机目录：容器内目录</li>\n</ul>\n<p>数据卷挂载与目录直接挂载的</p>\n<ul>\n<li>数据卷挂载耦合度低，由 docker 来管理目录，但是目录较深，不好找</li>\n<li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li>\n</ul>\n<h1 id=\"3dockerfile自定义镜像\"><a class=\"markdownIt-Anchor\" href=\"#3dockerfile自定义镜像\">#</a> 3.Dockerfile 自定义镜像</h1>\n<p>常见的镜像在 DockerHub 就能找到，但是我们自己写的项目就必须自己构建镜像了。</p>\n<p>而要自定义镜像，就必须先了解镜像的结构才行。</p>\n<h2 id=\"31镜像结构\"><a class=\"markdownIt-Anchor\" href=\"#31镜像结构\">#</a> 3.1. 镜像结构</h2>\n<p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p>\n<p>我们以 MySQL 为例，来看看镜像的组成结构：</p>\n<p><img src=\"/assets/image-20210731175806273.png\" alt=\"image-20210731175806273\"></p>\n<p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p>\n<p>我们要构建镜像，其实就是实现上述打包的过程。</p>\n<h2 id=\"32dockerfile语法\"><a class=\"markdownIt-Anchor\" href=\"#32dockerfile语法\">#</a> 3.2.Dockerfile 语法</h2>\n<p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p>\n<p>我们只需要告诉 Docker，我们的镜像的组成，需要哪些 BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来 Docker 会帮助我们构建镜像。</p>\n<p>而描述上述信息的文件就是 Dockerfile 文件。</p>\n<p><strong>Dockerfile</strong> 就是一个文本文件，其中包含一个个的<strong>指令 (Instruction)</strong>，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层 Layer。</p>\n<p><img src=\"/assets/image-20210731180321133.png\" alt=\"image-20210731180321133\"></p>\n<p>更新详细语法说明，请参考官网文档： <a href=\"https://docs.docker.com/engine/reference/builder\">https://docs.docker.com/engine/reference/builder</a></p>\n<h2 id=\"33构建java项目\"><a class=\"markdownIt-Anchor\" href=\"#33构建java项目\">#</a> 3.3. 构建 Java 项目</h2>\n<h3 id=\"331基于ubuntu构建java项目\"><a class=\"markdownIt-Anchor\" href=\"#331基于ubuntu构建java项目\">#</a> 3.3.1. 基于 Ubuntu 构建 Java 项目</h3>\n<p>需求：基于 Ubuntu 镜像构建一个新镜像，运行一个 java 项目</p>\n<ul>\n<li>\n<p>步骤 1：新建一个空文件夹 docker-demo</p>\n<p><img src=\"/assets/image-20210801101207444.png\" alt=\"image-20210801101207444\"></p>\n</li>\n<li>\n<p>步骤 2：拷贝课前资料中的 docker-demo.jar 文件到 docker-demo 这个目录</p>\n<p><img src=\"/assets/image-20210801101314816.png\" alt=\"image-20210801101314816\"></p>\n</li>\n<li>\n<p>步骤 3：拷贝课前资料中的 jdk8.tar.gz 文件到 docker-demo 这个目录</p>\n<p><img src=\"/assets/image-20210801101410200.png\" alt=\"image-20210801101410200\"></p>\n</li>\n<li>\n<p>步骤 4：拷贝课前资料提供的 Dockerfile 到 docker-demo 这个目录</p>\n<p><img src=\"/assets/image-20210801101455590.png\" alt=\"image-20210801101455590\"></p>\n<p>其中的内容如下：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定基础镜像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu:<span class=\"number\">16.04</span></span><br><span class=\"line\"><span class=\"comment\"># 配置环境变量，JDK的安装目录</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> JAVA_DIR=/usr/local</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝jdk和java项目的包</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> ./jdk8.tar.gz <span class=\"variable\">$JAVA_DIR</span>/</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装JDK</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">cd</span> <span class=\"variable\">$JAVA_DIR</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\"> &amp;&amp; tar -xf ./jdk8.tar.gz \\</span></span><br><span class=\"line\"><span class=\"language-bash\"> &amp;&amp; <span class=\"built_in\">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class=\"line\"><span class=\"keyword\">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暴露端口</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8090</span></span><br><span class=\"line\"><span class=\"comment\"># 入口，java项目的启动命令</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>步骤 5：进入 docker-demo</p>\n<p>将准备好的 docker-demo 上传到虚拟机任意目录，然后进入 docker-demo 目录下</p>\n</li>\n<li>\n<p>步骤 6：运行命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t javaweb:1.0 .</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>最后访问 <a href=\"http://192.168.150.101:8090/hello/count%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84ip%E6%94%B9%E6%88%90%E4%BD%A0%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BAip\">http://192.168.150.101:8090/hello/count，其中的 ip 改成你的虚拟机 ip</a></p>\n<h3 id=\"332基于java8构建java项目\"><a class=\"markdownIt-Anchor\" href=\"#332基于java8构建java项目\">#</a> 3.3.2. 基于 java8 构建 Java 项目</h3>\n<p>虽然我们可以基于 Ubuntu 基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p>\n<p>例如，构建 java 项目的镜像，可以在已经准备了 JDK 的基础镜像基础上构建。</p>\n<p>需求：基于 java:8-alpine 镜像，将一个 Java 项目构建为镜像</p>\n<p>实现思路如下：</p>\n<ul>\n<li>\n<p>① 新建一个空的目录，然后在目录中新建一个文件，命名为 Dockerfile</p>\n</li>\n<li>\n<p>② 拷贝课前资料提供的 docker-demo.jar 到这个目录中</p>\n</li>\n<li>\n<p>③ 编写 Dockerfile 文件：</p>\n<ul>\n<li>\n<p>a ）基于 java:8-alpine 作为基础镜像</p>\n</li>\n<li>\n<p>b ）将 app.jar 拷贝到镜像中</p>\n</li>\n<li>\n<p>c ）暴露端口</p>\n</li>\n<li>\n<p>d ）编写入口 ENTRYPOINT</p>\n<p>内容如下：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> java:<span class=\"number\">8</span>-alpine</span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> ./app.jar /tmp/app.jar</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8090</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>④ 使用 docker build 命令构建镜像</p>\n</li>\n<li>\n<p>⑤ 使用 docker run 创建容器并运行</p>\n</li>\n</ul>\n<h2 id=\"34小结\"><a class=\"markdownIt-Anchor\" href=\"#34小结\">#</a> 3.4. 小结</h2>\n<p>小结：</p>\n<ol>\n<li>\n<p>Dockerfile 的本质是一个文件，通过指令描述镜像的构建过程</p>\n</li>\n<li>\n<p>Dockerfile 的第一行必须是 FROM，从一个基础镜像来构建</p>\n</li>\n<li>\n<p>基础镜像可以是基本操作系统，如 Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p>\n</li>\n</ol>\n<h1 id=\"4docker-compose\"><a class=\"markdownIt-Anchor\" href=\"#4docker-compose\">#</a> 4.Docker-Compose</h1>\n<p>Docker Compose 可以基于 Compose 文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p>\n<p><img src=\"/assets/image-20210731180921742.png\" alt=\"image-20210731180921742\"></p>\n<h2 id=\"41初识dockercompose\"><a class=\"markdownIt-Anchor\" href=\"#41初识dockercompose\">#</a> 4.1. 初识 DockerCompose</h2>\n<p>Compose 文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version<span class=\"punctuation\">:</span> <span class=\"string\">&quot;3.8&quot;</span></span><br><span class=\"line\"> services<span class=\"punctuation\">:</span></span><br><span class=\"line\">  mysql<span class=\"punctuation\">:</span></span><br><span class=\"line\">    image<span class=\"punctuation\">:</span> mysql<span class=\"punctuation\">:</span><span class=\"number\">5.7</span><span class=\"number\">.25</span></span><br><span class=\"line\">    environment<span class=\"punctuation\">:</span></span><br><span class=\"line\">     MYSQL_ROOT_PASSWORD<span class=\"punctuation\">:</span> <span class=\"number\">123</span> </span><br><span class=\"line\">    volumes<span class=\"punctuation\">:</span></span><br><span class=\"line\">     - <span class=\"string\">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span></span><br><span class=\"line\">     - <span class=\"string\">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span></span><br><span class=\"line\">  web<span class=\"punctuation\">:</span></span><br><span class=\"line\">    build<span class=\"punctuation\">:</span> .</span><br><span class=\"line\">    ports<span class=\"punctuation\">:</span></span><br><span class=\"line\">     - <span class=\"string\">&quot;8090:8090&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上面的 Compose 文件就描述一个项目，其中包含两个容器：</p>\n<ul>\n<li>mysql：一个基于 <code>mysql:5.7.25</code>  镜像构建的容器，并且挂载了两个目录</li>\n<li>web：一个基于 <code>docker build</code>  临时构建的镜像容器，映射端口时 8090</li>\n</ul>\n<p>DockerCompose 的详细语法参考官网：<a href=\"https://docs.docker.com/compose/compose-file/\">https://docs.docker.com/compose/compose-file/</a></p>\n<p>其实 DockerCompose 文件可以看做是将多个 docker run 命令写到一个文件，只是语法稍有差异。</p>\n<h2 id=\"42安装dockercompose\"><a class=\"markdownIt-Anchor\" href=\"#42安装dockercompose\">#</a> 4.2. 安装 DockerCompose</h2>\n<p>参考课前资料</p>\n<h2 id=\"43部署微服务集群\"><a class=\"markdownIt-Anchor\" href=\"#43部署微服务集群\">#</a> 4.3. 部署微服务集群</h2>\n<p><strong>需求</strong>：将之前学习的 cloud-demo 微服务集群利用 DockerCompose 部署</p>\n<p><strong>实现思路</strong>：</p>\n<p>① 查看课前资料提供的 cloud-demo 文件夹，里面已经编写好了 docker-compose 文件</p>\n<p>② 修改自己的 cloud-demo 项目，将数据库、nacos 地址都命名为 docker-compose 中的服务名</p>\n<p>③ 使用 maven 打包工具，将项目中的每个微服务都打包为 app.jar</p>\n<p>④ 将打包好的 app.jar 拷贝到 cloud-demo 中的每一个对应的子目录中</p>\n<p>⑤ 将 cloud-demo 上传至虚拟机，利用 docker-compose up -d 来部署</p>\n<h3 id=\"431compose文件\"><a class=\"markdownIt-Anchor\" href=\"#431compose文件\">#</a> 4.3.1.compose 文件</h3>\n<p>查看课前资料提供的 cloud-demo 文件夹，里面已经编写好了 docker-compose 文件，而且每个微服务都准备了一个独立的目录：</p>\n<p><img src=\"/assets/image-20210731181341330.png\" alt=\"image-20210731181341330\"></p>\n<p>内容如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&quot;3.2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">nacos:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nacos/nacos-server</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">MODE:</span> <span class=\"string\">standalone</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;8848:8848&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">mysql:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7.25</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_ROOT_PASSWORD:</span> <span class=\"number\">123</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;$PWD/mysql/data:/var/lib/mysql&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">userservice:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">./user-service</span></span><br><span class=\"line\">  <span class=\"attr\">orderservice:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">./order-service</span></span><br><span class=\"line\">  <span class=\"attr\">gateway:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">./gateway</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;10010:10010&quot;</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，其中包含 5 个 service 服务：</p>\n<ul>\n<li><code>nacos</code> ：作为注册中心和配置中心\n<ul>\n<li><code>image: nacos/nacos-server</code> ： 基于 nacos/nacos-server 镜像构建</li>\n<li><code>environment</code> ：环境变量\n<ul>\n<li><code>MODE: standalone</code> ：单点模式启动</li>\n</ul>\n</li>\n<li><code>ports</code> ：端口映射，这里暴露了 8848 端口</li>\n</ul>\n</li>\n<li><code>mysql</code> ：数据库\n<ul>\n<li><code>image: mysql:5.7.25</code> ：镜像版本是 mysql:5.7.25</li>\n<li><code>environment</code> ：环境变量\n<ul>\n<li><code>MYSQL_ROOT_PASSWORD: 123</code> ：设置数据库 root 账户的密码为 123</li>\n</ul>\n</li>\n<li><code>volumes</code> ：数据卷挂载，这里挂载了 mysql 的 data、conf 目录，其中有我提前准备好的数据</li>\n</ul>\n</li>\n<li><code>userservice</code> 、 <code>orderservice</code> 、 <code>gateway</code> ：都是基于 Dockerfile 临时构建的</li>\n</ul>\n<p>查看 mysql 目录，可以看到其中已经准备好了 cloud_order、cloud_user 表：</p>\n<p><img src=\"/assets/image-20210801095205034.png\" alt=\"image-20210801095205034\"></p>\n<p>查看微服务目录，可以看到都包含 Dockerfile 文件：</p>\n<p><img src=\"/assets/image-20210801095320586.png\" alt=\"image-20210801095320586\"></p>\n<p>内容如下：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> java:<span class=\"number\">8</span>-alpine</span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> ./app.jar /tmp/app.jar</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"432修改微服务配置\"><a class=\"markdownIt-Anchor\" href=\"#432修改微服务配置\">#</a> 4.3.2. 修改微服务配置</h3>\n<p>因为微服务将来要部署为 docker 容器，而容器之间互联不是通过 IP 地址，而是通过容器名。这里我们将 order-service、user-service、gateway 服务的 mysql、nacos 地址都修改为基于容器名的访问。</p>\n<p>如下所示：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">datasource:</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">jdbc:mysql://mysql:3306/cloud_order?useSSL=false</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"number\">123</span></span><br><span class=\"line\">    <span class=\"attr\">driver-class-name:</span> <span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\">  <span class=\"attr\">application:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">orderservice</span></span><br><span class=\"line\">  <span class=\"attr\">cloud:</span></span><br><span class=\"line\">    <span class=\"attr\">nacos:</span></span><br><span class=\"line\">      <span class=\"attr\">server-addr:</span> <span class=\"string\">nacos:8848</span> <span class=\"comment\"># nacos服务地址</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"433打包\"><a class=\"markdownIt-Anchor\" href=\"#433打包\">#</a> 4.3.3. 打包</h3>\n<p>接下来需要将我们的每个微服务都打包。因为之前查看到 Dockerfile 中的 jar 包名称都是 app.jar，因此我们的每个微服务都需要用这个名称。</p>\n<p>可以通过修改 pom.xml 中的打包名称来实现，每个微服务都需要修改：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 服务打包的最终名称 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">finalName</span>&gt;</span>app<span class=\"tag\">&lt;/<span class=\"name\">finalName</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>打包后：</p>\n<p><img src=\"/assets/image-20210801095951030.png\" alt=\"image-20210801095951030\"></p>\n<h3 id=\"434拷贝jar包到部署目录\"><a class=\"markdownIt-Anchor\" href=\"#434拷贝jar包到部署目录\">#</a> 4.3.4. 拷贝 jar 包到部署目录</h3>\n<p>编译打包好的 app.jar 文件，需要放到 Dockerfile 的同级目录中。注意：每个微服务的 app.jar 放到与服务名称对应的目录，别搞错了。</p>\n<p>user-service：</p>\n<p><img src=\"/assets/image-20210801100201253.png\" alt=\"image-20210801100201253\"></p>\n<p>order-service：</p>\n<p><img src=\"/assets/image-20210801100231495.png\" alt=\"image-20210801100231495\"></p>\n<p>gateway：</p>\n<p><img src=\"/assets/image-20210801100308102.png\" alt=\"image-20210801100308102\"></p>\n<h3 id=\"435部署\"><a class=\"markdownIt-Anchor\" href=\"#435部署\">#</a> 4.3.5. 部署</h3>\n<p>最后，我们需要将文件整个 cloud-demo 文件夹上传到虚拟机中，理由 DockerCompose 部署。</p>\n<p>上传到任意目录：</p>\n<p><img src=\"/assets/image-20210801100955653.png\" alt=\"image-20210801100955653\"></p>\n<p>部署：</p>\n<p>进入 cloud-demo 目录，然后运行下面的命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n<h1 id=\"5docker镜像仓库\"><a class=\"markdownIt-Anchor\" href=\"#5docker镜像仓库\">#</a> 5.Docker 镜像仓库</h1>\n<h2 id=\"51搭建私有镜像仓库\"><a class=\"markdownIt-Anchor\" href=\"#51搭建私有镜像仓库\">#</a> 5.1. 搭建私有镜像仓库</h2>\n<p>参考课前资料《<a href=\"http://xn--CentOS7Docker-hm0y4670c.md\">CentOS7 安装 Docker.md</a>》</p>\n<h2 id=\"52推送-拉取镜像\"><a class=\"markdownIt-Anchor\" href=\"#52推送-拉取镜像\">#</a> 5.2. 推送、拉取镜像</h2>\n<p>推送镜像到私有镜像服务必须先 tag，步骤如下：</p>\n<p>① 重新 tag 本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>\n<p>② 推送镜像</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker push 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>\n<p>③ 拉取镜像</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "教程",
                "Docker"
            ]
        }
    ]
}